// Example file showing how to use Duvet annotations for compliance testing

use crate::record::ProtocolVersion;
use crate::error::Error;

//= https://www.rfc-editor.org/rfc/rfc8446#section-4.1.2
//# struct {
//#   ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
//#   Random random;
//#   opaque legacy_session_id<0..32>;
//#   CipherSuite cipher_suites<2..2^16-2>;
//#   opaque legacy_compression_methods<1..2^8-1>;
//#   Extension extensions<8..2^16-1>;
//# } ClientHello;
#[derive(Debug, Clone, PartialEq)]
pub struct ClientHello {
    pub legacy_version: ProtocolVersion,
    pub random: [u8; 32],
    pub legacy_session_id: Vec<u8>,
    pub cipher_suites: Vec<u8>,
    pub legacy_compression_methods: Vec<u8>,
    pub extensions: Vec<u8>,
}

impl ClientHello {
    //= https://www.rfc-editor.org/rfc/rfc8446#section-4.1.2
    //# When a client first connects to a server, it is REQUIRED to send the
    //# ClientHello as its first TLS message.
    pub fn new() -> Self {
        Self {
            legacy_version: ProtocolVersion { major: 3, minor: 3 }, // TLS 1.2
            random: [0; 32],
            legacy_session_id: Vec::new(),
            cipher_suites: Vec::new(),
            legacy_compression_methods: vec![0], // no compression
            extensions: Vec::new(),
        }
    }
    
    //= https://www.rfc-editor.org/rfc/rfc8446#section-4.1.2
    //# legacy_version:  In previous versions of TLS, this field was used for
    //# version negotiation and represented the highest version number
    //# supported by the client.  Experience has shown that many servers
    //# do not properly implement version negotiation, leading to "version
    //# intolerance" in which the server rejects an otherwise acceptable
    //# ClientHello with a version number higher than it supports.  In
    //# TLS 1.3, the client indicates its version preferences in the
    //# "supported_versions" extension (Section 4.2.1) and the
    //# legacy_version field MUST be set to 0x0303, which is the version
    //# number for TLS 1.2.  TLS 1.3 ClientHellos are identified as having
    //# a legacy_version of 0x0303 and a supported_versions extension
    //# present with 0x0304 as the highest version indicated therein.
    //# (See Appendix D for details about backward compatibility.)
    pub fn set_legacy_version(&mut self, version: ProtocolVersion) {
        self.legacy_version = version;
    }
    
    //= https://www.rfc-editor.org/rfc/rfc8446#section-4.1.2
    //# random:  32 bytes generated by a secure random number generator.  See
    //# Appendix C for additional information.
    pub fn set_random(&mut self, random: [u8; 32]) {
        self.random = random;
    }
    
    //= https://www.rfc-editor.org/rfc/rfc8446#section-4.1.2
    //# legacy_session_id:  Versions of TLS before TLS 1.3 supported a
    //# "session resumption" feature which has been merged with pre-shared
    //# keys in this version (see Section 2.2).  A client which has a
    //# cached session ID set by a pre-TLS 1.3 server SHOULD set this
    //# field to that value.  In compatibility mode (see Appendix D.4),
    //# this field MUST be non-empty, so a client not offering a
    //# pre-TLS 1.3 session MUST generate a new 32-byte value.  This value
    //# need not be random but SHOULD be unpredictable to avoid
    //# implementations fixating on a specific value (also known as
    //# ossification).  Otherwise, it MUST be set as a zero-length vector
    //# (i.e., a zero-valued single byte length field).
    pub fn set_legacy_session_id(&mut self, session_id: Vec<u8>) -> Result<(), Error> {
        if session_id.len() > 32 {
            return Err(Error::protocol(crate::error::ProtocolError::Other("Session ID too long".into())));
        }
        self.legacy_session_id = session_id;
        Ok(())
    }
    
    // Additional methods would be implemented here
}
