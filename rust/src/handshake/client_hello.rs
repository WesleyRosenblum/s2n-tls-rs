// Example file showing how to use Duvet annotations for compliance testing

use crate::record::ProtocolVersion;
use crate::error::Error;

//= https://tools.ietf.org/html/rfc8446#section-4.1.2
//# struct {
//#   ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
//#   Random random;
//#   opaque legacy_session_id<0..32>;
//#   CipherSuite cipher_suites<2..2^16-2>;
//#   opaque legacy_compression_methods<1..2^8-1>;
//#   Extension extensions<8..2^16-1>;
//# } ClientHello;
#[derive(Debug, Clone, PartialEq)]
pub struct ClientHello {
    pub legacy_version: ProtocolVersion,
    pub random: [u8; 32],
    pub legacy_session_id: Vec<u8>,
    pub cipher_suites: Vec<u8>,
    pub legacy_compression_methods: Vec<u8>,
    pub extensions: Vec<u8>,
}

impl ClientHello {
    //= https://tools.ietf.org/html/rfc8446#section-4.1.2
    //# The first message sent by the client in the handshake.
    pub fn new() -> Self {
        Self {
            legacy_version: ProtocolVersion { major: 3, minor: 3 }, // TLS 1.2
            random: [0; 32],
            legacy_session_id: Vec::new(),
            cipher_suites: Vec::new(),
            legacy_compression_methods: vec![0], // no compression
            extensions: Vec::new(),
        }
    }
    
    //= https://tools.ietf.org/html/rfc8446#section-4.1.2
    //# legacy_version:  In previous versions of TLS, this field was used for
    //# version negotiation and represented the highest version number
    //# supported by the client.  For compatibility with older servers,
    //# TLS 1.3 clients MUST set this field to 0x0303, which is the version
    //# number for TLS 1.2.
    pub fn set_legacy_version(&mut self, version: ProtocolVersion) {
        self.legacy_version = version;
    }
    
    //= https://tools.ietf.org/html/rfc8446#section-4.1.2
    //# random:  32 bytes generated by a secure random number generator.
    pub fn set_random(&mut self, random: [u8; 32]) {
        self.random = random;
    }
    
    //= https://tools.ietf.org/html/rfc8446#section-4.1.2
    //# legacy_session_id:  Versions of TLS before TLS 1.3 supported a
    //# "session resumption" feature which has been merged with pre-shared
    //# keys in this version.  This field MUST be of length 32 or less.
    pub fn set_legacy_session_id(&mut self, session_id: Vec<u8>) -> Result<(), Error> {
        if session_id.len() > 32 {
            return Err(Error::Protocol("Session ID too long".into()));
        }
        self.legacy_session_id = session_id;
        Ok(())
    }
    
    // Additional methods would be implemented here
}