SPECIFICATION: https://www.rfc-editor.org/rfc/rfc4492
  SECTION: [Key Exchange Algorithms](#section-2)
    TEXT[!SHOULD]: Implementations of this
    TEXT[!SHOULD]:    algorithm SHOULD provide authentication by other means.

  SECTION: [ECDH_ECDSA](#section-2.1)
    TEXT[!MUST]:    In ECDH_ECDSA, the server's certificate MUST contain an ECDH-capable
    TEXT[!MUST]:    public key and be signed with ECDSA.
    TEXT[!MUST]:    A ServerKeyExchange MUST NOT be sent (the server's certificate
    TEXT[!MUST]:    contains all the necessary keying information required by the client
    TEXT[!MUST]:    to arrive at the premaster secret).

  SECTION: [ECDHE_ECDSA](#section-2.2)
    TEXT[!MUST]:    In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA-
    TEXT[!MUST]:    capable public key and be signed with ECDSA.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST be signed with ECDSA using the private key
    TEXT[!MUST]:    corresponding to the public key in the server's Certificate.

  SECTION: [ECDH_RSA](#section-2.3)
    TEXT[!MUST]:    This key exchange algorithm is the same as ECDH_ECDSA except that the
    TEXT[!MUST]:    server's certificate MUST be signed with RSA rather than ECDSA.

  SECTION: [ECDHE_RSA](#section-2.4)
    TEXT[!MUST]:    This key exchange algorithm is the same as ECDHE_ECDSA except that
    TEXT[!MUST]:    the server's certificate MUST contain an RSA public key authorized
    TEXT[!MUST]:    for signing, and that the signature in the ServerKeyExchange message
    TEXT[!MUST]:    must be computed with the corresponding RSA private key.
    TEXT[!MUST]: The server
    TEXT[!MUST]:    certificate MUST be signed with RSA.

  SECTION: [ECDH_anon](#section-2.5)
    TEXT[!MUST]:    In ECDH_anon, the server's Certificate, the CertificateRequest, the
    TEXT[!MUST]:    client's Certificate, and the CertificateVerify messages MUST NOT be
    TEXT[!MUST]:    sent.
    TEXT[!MUST]:    The server MUST send an ephemeral ECDH public key and a specification
    TEXT[!MUST]:    of the corresponding curve in the ServerKeyExchange message.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST NOT be signed.

  SECTION: [ECDSA_sign](#section-3.1)
    TEXT[!MUST]:    To use this authentication mechanism, the client MUST possess a
    TEXT[!MUST]:    certificate containing an ECDSA-capable public key and signed with
    TEXT[!MUST]:    ECDSA.

  SECTION: [ECDSA_fixed_ECDH](#section-3.2)
    TEXT[!MUST]:    To use this authentication mechanism, the client MUST possess a
    TEXT[!MUST]:    certificate containing an ECDH-capable public key, and that
    TEXT[!MUST]:    certificate MUST be signed with ECDSA.
    TEXT[!MUST]: Furthermore, the client's
    TEXT[!MUST]:    ECDH key MUST be on the same elliptic curve as the server's long-term
    TEXT[!MUST]:    (certified) ECDH key.
    TEXT[!MUST]:    When using this authentication mechanism, the client MUST send an
    TEXT[!MUST]:    empty ClientKeyExchange as described in Section 5.7 and MUST NOT send
    TEXT[!MUST]:    the CertificateVerify message.

  SECTION: [RSA_fixed_ECDH](#section-3.3)
    TEXT[!MUST]:    This authentication mechanism is identical to ECDSA_fixed_ECDH except
    TEXT[!MUST]:    that the client's certificate MUST be signed with RSA.

  SECTION: [TLS Extensions for ECC](#section-4)
    TEXT[!SHOULD]:    A TLS client that proposes ECC cipher suites in its ClientHello
    TEXT[!SHOULD]:    message SHOULD include these extensions.
    TEXT[!MUST]: Servers implementing ECC
    TEXT[!MUST]:    cipher suites MUST support these extensions, and when a client uses
    TEXT[!MUST]:    these extensions, servers MUST NOT negotiate the use of an ECC cipher
    TEXT[!MUST]:    suite unless they can complete the handshake while respecting the
    TEXT[!MUST]:    choice of curves and compression techniques specified by the client.
    TEXT[!MUST]:    The client MUST NOT include these extensions in the ClientHello
    TEXT[!MUST]:    message if it does not propose any ECC cipher suites.

  SECTION: [Client Hello Extensions](#section-5.1)
    TEXT[!SHOULD]:    The extensions SHOULD be sent along with any ClientHello message that
    TEXT[!SHOULD]:    proposes ECC cipher suites.
    TEXT[!SHOULD]: Clients
    TEXT[!SHOULD]:    SHOULD send both the Supported Elliptic Curves Extension and the
    TEXT[!SHOULD]:    Supported Point Formats Extension.
    TEXT[!MUST]: If the Supported Point Formats
    TEXT[!MUST]:    Extension is indeed sent, it MUST contain the value 0 (uncompressed)
    TEXT[!MUST]:    as one of the items in the list of point formats.
    TEXT[!MUST]:    A server that receives a ClientHello containing one or both of these
    TEXT[!MUST]:    extensions MUST use the client's enumerated capabilities to guide its
    TEXT[!MUST]:    selection of an appropriate cipher suite.
    TEXT[!MUST]:    If a server does not understand the Supported Elliptic Curves
    TEXT[!MUST]:    Extension, does not understand the Supported Point Formats Extension,
    TEXT[!MUST]:    or is unable to complete the ECC handshake while restricting itself
    TEXT[!MUST]:    to the enumerated curves and point formats, it MUST NOT negotiate the
    TEXT[!MUST]:    use of an ECC cipher suite.

  SECTION: [Supported Point Formats Extension](#section-5.1.2)
    TEXT[!MUST]: The uncompressed point format is the default format in that
    TEXT[!MUST]:    implementations of this document MUST support it for all of their
    TEXT[!MUST]:    supported curves.
    TEXT[!MAY]: Implementations of this document MAY support the
    TEXT[!MAY]:    ansiX962_compressed_prime and ansiX962_compressed_char2 formats,
    TEXT[!MAY]:    where the former applies only to prime curves and the latter applies
    TEXT[!MAY]:    only to characteristic-2 curves.

  SECTION: [Server Hello Extension](#section-5.2)
    TEXT[!MUST]: The Supported
    TEXT[!MUST]:    Point Formats Extension, when used, MUST contain the value 0
    TEXT[!MUST]:    (uncompressed) as one of the items in the list of point formats.
    TEXT[!MUST]:    A client that receives a ServerHello message containing a Supported
    TEXT[!MUST]:    Point Formats Extension MUST respect the server's choice of point
    TEXT[!MUST]:    formats during the handshake (cf.

  SECTION: [Server Certificate](#section-5.3)
    TEXT[!MUST]: ECC
    TEXT[!MUST]:    public keys MUST be encoded in certificates as described in
    TEXT[!MUST]:    Section 5.9.
    TEXT[!MUST]:           ECDH_ECDSA              Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key.
    TEXT[!MUST]: It
    TEXT[!MUST]:                                   MUST be signed with ECDSA.
    TEXT[!MUST]:           ECDHE_ECDSA             Certificate MUST contain an
    TEXT[!MUST]:                                   ECDSA-capable public key.
    TEXT[!MUST]:           ECDH_RSA                Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key.
    TEXT[!MUST]: It
    TEXT[!MUST]:                                   MUST be signed with RSA.
    TEXT[!MUST]:           ECDHE_RSA               Certificate MUST contain an
    TEXT[!MUST]:                                   RSA public key authorized for
    TEXT[!MUST]:                                   use in digital signatures.
    TEXT[!MUST]: If the client has used a
    TEXT[!MUST]:    Supported Elliptic Curves Extension, the public key in the server's
    TEXT[!MUST]:    certificate MUST respect the client's choice of elliptic curves; in
    TEXT[!MUST]:    particular, the public key MUST employ a named curve (not the same
    TEXT[!MUST]:    curve as an explicit curve) unless the client has indicated support
    TEXT[!MUST]:    for explicit curves of the appropriate type.
    TEXT[!MUST]: If the client has used
    TEXT[!MUST]:    a Supported Point Formats Extension, both the server's public key
    TEXT[!MUST]:    point and (in the case of an explicit curve) the curve's base point
    TEXT[!MUST]:    MUST respect the client's choice of point formats.
    TEXT[!MUST]: (A server that
    TEXT[!MUST]:    cannot satisfy these requirements MUST NOT choose an ECC cipher suite
    TEXT[!MUST]:    in its ServerHello message.)

  SECTION: [Server Key Exchange](#section-5.4)
    TEXT[!SHOULD]: This option
    TEXT[!SHOULD]:       SHOULD be used when applicable.
    TEXT[!MUST]: This byte string may represent an elliptic curve point
    TEXT[!MUST]:       in uncompressed or compressed format; it MUST conform to what the
    TEXT[!MUST]:       client has requested through a Supported Point Formats Extension
    TEXT[!MUST]:       if this extension was used.

  SECTION: [Client Certificate](#section-5.6)
    TEXT[!MUST]:           ECDSA_sign              Certificate MUST contain an
    TEXT[!MUST]:                                   ECDSA-capable public key and
    TEXT[!MUST]:                                   be signed with ECDSA.
    TEXT[!MUST]:           ECDSA_fixed_ECDH        Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key on the
    TEXT[!MUST]:                                   same elliptic curve as the server's
    TEXT[!MUST]:                                   long-term ECDH key.
    TEXT[!MUST]: This certificate
    TEXT[!MUST]:                                   MUST be signed with ECDSA.
    TEXT[!MUST]:           RSA_fixed_ECDH          Certificate MUST contain an
    TEXT[!MUST]:                                   ECDH-capable public key on the
    TEXT[!MUST]:                                   same elliptic curve as the server's
    TEXT[!MUST]:                                   long-term ECDH key.
    TEXT[!MUST]: This certificate
    TEXT[!MUST]:                                   MUST be signed with RSA.

  SECTION: [Client Key Exchange](#section-5.7)
    TEXT[!MUST]: Here, the format MUST
    TEXT[!MUST]:       conform to what the server has requested through a Supported Point
    TEXT[!MUST]:       Formats Extension if this extension was used, and MUST be
    TEXT[!MUST]:       uncompressed if this extension was not used.

  SECTION: [Elliptic Curve Certificates](#section-5.9)
    TEXT[!MUST]:    X.509 certificates containing ECC public keys or signed using ECDSA
    TEXT[!MUST]:    MUST comply with [14] or another RFC that replaces or extends it.
    TEXT[!SHOULD]:    Clients SHOULD use the elliptic curve domain parameters recommended
    TEXT[!SHOULD]:    in ANSI X9.62 [7], FIPS 186-2 [11], and SEC 2 [13].

  SECTION: [ECDH, ECDSA, and RSA Computations](#section-5.10)
    TEXT[!MUST]: Note that this octet string (Z in IEEE 1363 terminology) as
    TEXT[!MUST]:    output by FE2OSP, the Field Element to Octet String Conversion
    TEXT[!MUST]:    Primitive, has constant length for any given field; leading zeros
    TEXT[!MUST]:    found in this octet string MUST NOT be truncated.
    TEXT[!MUST]:    All ECDSA computations MUST be performed according to ANSI X9.62 [7]
    TEXT[!MUST]:    or its successors.

  SECTION: [Cipher Suites](#section-6)
    TEXT[!SHOULD]:    Server implementations SHOULD support all of the following cipher
    TEXT[!SHOULD]:    suites, and client implementations SHOULD support at least one of
    TEXT[!SHOULD]:    them: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
    TEXT[!SHOULD]:    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,
    TEXT[!SHOULD]:    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, and
    TEXT[!SHOULD]:    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5246
  SECTION: [Major Differences from TLS 1.1](#section-1.2)
    TEXT[!MUST]:    -  Alerts MUST now be sent in many cases.
    TEXT[!MUST]:    -  After a certificate_request, if no certificates are available,
    TEXT[!MUST]:       clients now MUST send an empty certificate list.
    TEXT[!SHOULD]:    -  Support for the SSLv2 backward-compatible hello is now a MAY, not
    TEXT[!SHOULD]:       a SHOULD, with sending it a SHOULD NOT.
    TEXT[!SHOULD]: Support will probably
    TEXT[!SHOULD]:       become a SHOULD NOT in the future.

  SECTION: [Cryptographic Attributes](#section-4.7)
    TEXT[!MUST]: As
    TEXT[!MUST]:    discussed in [PKCS1], the DigestInfo MUST be DER-encoded [X680]
    TEXT[!MUST]:    [X690].
    TEXT[!MUST]: For hash algorithms without parameters (which includes
    TEXT[!MUST]:    SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be
    TEXT[!MUST]:    NULL, but implementations MUST accept both without parameters and
    TEXT[!MUST]:    with NULL parameters.

  SECTION: [HMAC and the Pseudorandom Function](#section-5)
    TEXT[!MAY]: Other cipher suites MAY define their
    TEXT[!MAY]:    own MAC constructions, if needed.
    TEXT[!MUST]: New cipher suites MUST explicitly specify a
    TEXT[!MUST]:    PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a
    TEXT[!MUST]:    stronger standard hash function.

  SECTION: [The TLS Record Protocol](#section-6)
    TEXT[!MUST]:    Implementations MUST NOT send record types not defined in this
    TEXT[!MUST]:    document unless negotiated by some extension.
    TEXT[!MUST]: If a TLS
    TEXT[!MUST]:    implementation receives an unexpected record type, it MUST send an
    TEXT[!MUST]:    unexpected_message alert.

  SECTION: [Connection States](#section-6.1)
    TEXT[!MUST]: These current states MUST be updated for each
    TEXT[!MUST]:    record processed.
    TEXT[!MUST]: The sequence
    TEXT[!MUST]:       number MUST be set to zero whenever a connection state is made the
    TEXT[!MUST]:       active state.
    TEXT[!MUST]: A sequence number is incremented after each
    TEXT[!MUST]:       record: specifically, the first record transmitted under a
    TEXT[!MUST]:       particular connection state MUST use sequence number 0.

  SECTION: [Fragmentation](#section-6.2.1)
    TEXT[!MAY]: Client
    TEXT[!MAY]:    message boundaries are not preserved in the record layer (i.e.,
    TEXT[!MAY]:    multiple client messages of the same ContentType MAY be coalesced
    TEXT[!MAY]:    into a single TLSPlaintext record, or a single message MAY be
    TEXT[!MAY]:    fragmented across several records).
    TEXT[!MUST]: The
    TEXT[!MUST]:       length MUST NOT exceed 2^14.
    TEXT[!MUST]:    Implementations MUST NOT send zero-length fragments of Handshake,
    TEXT[!MUST]:    Alert, or ChangeCipherSpec content types.
    TEXT[!MAY]: Zero-length fragments of
    TEXT[!MAY]:    Application data MAY be sent as they are potentially useful as a
    TEXT[!MAY]:    traffic analysis countermeasure.
    TEXT[!MAY]:    Note: Data of different TLS record layer content types MAY be
    TEXT[!MAY]:    interleaved.
    TEXT[!MUST]: However, records MUST be
    TEXT[!MUST]:    delivered to the network in the same order as they are protected by
    TEXT[!MUST]:    the record layer.
    TEXT[!MUST]: Recipients MUST receive and process interleaved
    TEXT[!MUST]:    application layer traffic during handshakes subsequent to the first
    TEXT[!MUST]:    one on a connection.

  SECTION: [Record Compression and Decompression](#section-6.2.2)
    TEXT[!MUST]: If the decompression function encounters a
    TEXT[!MUST]:    TLSCompressed.fragment that would decompress to a length in excess of
    TEXT[!MUST]:    2^14 bytes, it MUST report a fatal decompression failure error.
    TEXT[!MUST]:       The length MUST NOT exceed 2^14 + 1024.

  SECTION: [Record Payload Protection](#section-6.2.3)
    TEXT[!MUST]:       The length MUST NOT exceed 2^14 + 2048.

  SECTION: [CBC Block Cipher](#section-6.2.3.2)
    TEXT[!MUST]:    IV
    TEXT[!MUST]:       The Initialization Vector (IV) SHOULD be chosen at random, and
    TEXT[!MUST]:       MUST be unpredictable.
    TEXT[!MAY]: The
    TEXT[!MAY]:       padding MAY be any length up to 255 bytes, as long as it results
    TEXT[!MAY]:       in the TLSCiphertext.length being an integral multiple of the
    TEXT[!MAY]:       block length.
    TEXT[!MUST]: Each uint8 in the padding data
    TEXT[!MUST]:       vector MUST be filled with the padding length value.
    TEXT[!MUST]: The receiver
    TEXT[!MUST]:       MUST check this padding and MUST use the bad_record_mac alert to
    TEXT[!MUST]:       indicate padding errors.
    TEXT[!MUST]:    padding_length
    TEXT[!MUST]:       The padding length MUST be such that the total size of the
    TEXT[!MUST]:       GenericBlockCipher structure is a multiple of the cipher's block
    TEXT[!MUST]:       length.
    TEXT[!MUST]: In order to defend against this attack, implementations
    TEXT[!MUST]:    MUST ensure that record processing time is essentially the same
    TEXT[!MUST]:    whether or not the padding is correct.

  SECTION: [AEAD Ciphers](#section-6.2.3.3)
    TEXT[!MUST]:    Each AEAD cipher suite MUST specify how the nonce supplied to the
    TEXT[!MUST]:    AEAD operation is constructed, and what is the length of the
    TEXT[!MUST]:    GenericAEADCipher.nonce_explicit part.
    TEXT[!SHOULD]: In this case, the implicit part SHOULD be derived
    TEXT[!SHOULD]:    from key_block as client_write_iv and server_write_iv (as described
    TEXT[!SHOULD]:    in Section 6.3), and the explicit part is included in
    TEXT[!SHOULD]:    GenericAEAEDCipher.nonce_explicit.
    TEXT[!MUST]: Each
    TEXT[!MUST]:    AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.
    TEXT[!MUST]:    If the decryption fails, a fatal bad_record_mac alert MUST be
    TEXT[!MUST]:    generated.

  SECTION: [Change Cipher Spec Protocol](#section-7.1)
    TEXT[!MUST]:    Immediately after sending this message, the sender MUST instruct the
    TEXT[!MUST]:    record layer to make the write pending state the write active state.
    TEXT[!MUST]: However, once the ChangeCipherSpec has been sent, the
    TEXT[!MUST]:    new CipherSpec MUST be used.
    TEXT[!MAY]: Thus, a small window of time,
    TEXT[!MAY]:    during which the recipient must buffer the data, MAY exist.

  SECTION: [Alert Protocol](#section-7.2)
    TEXT[!MUST]: In this case, other connections corresponding to the
    TEXT[!MUST]:    session may continue, but the session identifier MUST be invalidated,
    TEXT[!MUST]:    preventing the failed session from being used to establish new
    TEXT[!MUST]:    connections.

  SECTION: [Closure Alerts](#section-7.2.1)
    TEXT[!MUST]: The other party MUST respond with a close_notify
    TEXT[!MUST]:    alert of its own and close down the connection immediately,
    TEXT[!MUST]:    discarding any pending writes.
    TEXT[!MAY]: If the application protocol will not
    TEXT[!MAY]:    transfer any additional data, but will only close the underlying
    TEXT[!MAY]:    transport connection, then the implementation MAY choose to close the
    TEXT[!MAY]:    transport without waiting for the responding close_notify.

  SECTION: [Error Alerts](#section-7.2.2)
    TEXT[!MUST]: Servers and clients MUST
    TEXT[!MUST]:    forget any session-identifiers, keys, and secrets associated with a
    TEXT[!MUST]:    failed connection.
    TEXT[!MUST]: Thus, any connection terminated with a fatal
    TEXT[!MUST]:    alert MUST NOT be resumed.
    TEXT[!MUST]:    Whenever an implementation encounters a condition which is defined as
    TEXT[!MUST]:    a fatal alert, it MUST send the appropriate alert prior to closing
    TEXT[!MUST]:    the connection.
    TEXT[!MAY]: For all errors where an alert level is not
    TEXT[!MAY]:    explicitly specified, the sending party MAY determine at its
    TEXT[!MAY]:    discretion whether to treat this as a fatal error or not.
    TEXT[!MUST]: If the
    TEXT[!MUST]:    implementation chooses to send an alert but intends to close the
    TEXT[!MUST]:    connection immediately afterwards, it MUST send that alert at the
    TEXT[!MUST]:    fatal alert level.
    TEXT[!SHOULD]: If the receiving party decides
    TEXT[!SHOULD]:    not to proceed with the connection (e.g., after having received a
    TEXT[!SHOULD]:    no_renegotiation alert that it is not willing to accept), it SHOULD
    TEXT[!SHOULD]:    send a fatal alert to terminate the connection.
    TEXT[!MUST]: This alert also MUST be returned if an alert is sent because
    TEXT[!MUST]:       a TLSCiphertext decrypted in an invalid way: either it wasn't an
    TEXT[!MUST]:       even multiple of the block length, or its padding values, when
    TEXT[!MUST]:       checked, weren't correct.
    TEXT[!MUST]: It MUST
    TEXT[!MUST]:       NOT be sent by compliant implementations.

  SECTION: [Handshake Protocol Overview](#section-7.3)
    TEXT[!MUST]: This secret MUST be quite long; currently defined key
    TEXT[!MUST]:    exchange methods exchange secrets that range from 46 bytes upwards.
    TEXT[!MUST]: If the server has sent
    TEXT[!MUST]:    a CertificateRequest message, the client MUST send the Certificate
    TEXT[!MUST]:    message.
    TEXT[!MUST]: (See
    TEXT[!MUST]:    flow chart below.)  Application data MUST NOT be sent prior to the
    TEXT[!MUST]:    completion of the first handshake (before a cipher suite other than
    TEXT[!MUST]:    TLS_NULL_WITH_NULL_NULL is established).
    TEXT[!MUST]: At this point, both
    TEXT[!MUST]:    client and server MUST send ChangeCipherSpec messages and proceed
    TEXT[!MUST]:    directly to Finished messages.
    TEXT[!MAY]: Once the re-establishment is
    TEXT[!MAY]:    complete, the client and server MAY begin to exchange application
    TEXT[!MAY]:    layer data.

  SECTION: [Handshake Protocol](#section-7.4)
    TEXT[!MUST]:    The handshake protocol messages are presented below in the order they
    TEXT[!MUST]:    MUST be sent; sending handshake messages in an unexpected order
    TEXT[!MUST]:    results in a fatal error.
    TEXT[!SHOULD]: The one message that is not bound by these ordering rules
    TEXT[!SHOULD]:    is the HelloRequest message, which can be sent at any time, but which
    TEXT[!SHOULD]:    SHOULD be ignored by the client if it arrives in the middle of a
    TEXT[!SHOULD]:    handshake.

  SECTION: [Hello Request](#section-7.4.1.1)
    TEXT[!MAY]:       The HelloRequest message MAY be sent by the server at any time.
    TEXT[!SHOULD]: Servers SHOULD NOT send a
    TEXT[!SHOULD]:       HelloRequest immediately upon the client's initial connection.
    TEXT[!MAY]: This message MAY be ignored by
    TEXT[!MAY]:       the client if it does not wish to renegotiate a session, or the
    TEXT[!MAY]:       client may, if it wishes, respond with a no_renegotiation alert.
    TEXT[!SHOULD]:       After sending a HelloRequest, servers SHOULD NOT repeat the
    TEXT[!SHOULD]:       request until the subsequent handshake negotiation is complete.
    TEXT[!MUST]:    This message MUST NOT be included in the message hashes that are
    TEXT[!MUST]:    maintained throughout the handshake and used in the Finished messages
    TEXT[!MUST]:    and the certificate verify message.

  SECTION: [Client Hello](#section-7.4.1.2)
    TEXT[!MAY]: The session identifier MAY be from an earlier connection,
    TEXT[!MUST]:    Warning: Because the SessionID is transmitted without encryption or
    TEXT[!MUST]:    immediate MAC protection, servers MUST NOT place confidential
    TEXT[!MUST]:    information in session identifiers or let the contents of fake
    TEXT[!MUST]:    session identifiers cause any breach of security.
    TEXT[!MUST]: If the list contains cipher
    TEXT[!MUST]:    suites the server does not recognize, support, or wish to use, the
    TEXT[!MUST]:    server MUST ignore those cipher suites, and process the remaining
    TEXT[!MUST]:    ones as usual.
    TEXT[!SHOULD]: This SHOULD be the latest
    TEXT[!SHOULD]:       (highest valued) version supported by the client.
    TEXT[!MUST]: If the
    TEXT[!MUST]:       session_id field is not empty (implying a session resumption
    TEXT[!MUST]:       request), this vector MUST include at least the cipher_suite from
    TEXT[!MUST]:       that session.
    TEXT[!MUST]: If the session_id field is not empty
    TEXT[!MUST]:       (implying a session resumption request), it MUST include the
    TEXT[!MUST]: This vector MUST contain,
    TEXT[!MUST]:       and all implementations MUST support, CompressionMethod.null.
    TEXT[!MAY]:    extensions
    TEXT[!MAY]:       Clients MAY request extended functionality from servers by sending
    TEXT[!MAY]:       data in the extensions field.
    TEXT[!MAY]:    In the event that a client requests additional functionality using
    TEXT[!MAY]:    extensions, and this functionality is not supplied by the server, the
    TEXT[!MAY]:    client MAY abort the handshake.
    TEXT[!MUST]: A server MUST accept ClientHello
    TEXT[!MUST]:    messages both with and without the extensions field, and (as for all
    TEXT[!MUST]:    other messages) it MUST check that the amount of data in the message
    TEXT[!MUST]:    precisely matches one of these formats; if not, then it MUST send a
    TEXT[!MUST]:    fatal "decode_error" alert.

  SECTION: [Server Hello](#section-7.4.1.3)
    TEXT[!MUST]:    random
    TEXT[!MUST]:       This structure is generated by the server and MUST be
    TEXT[!MUST]:       independently generated from the ClientHello.random.
    TEXT[!MUST]: Clients MUST be prepared to do a full
    TEXT[!MUST]:       negotiation -- including negotiating new cipher suites -- during
    TEXT[!MUST]:       any handshake.

  SECTION: [Hello Extensions](#section-7.4.1.4)
    TEXT[!MUST]:    An extension type MUST NOT appear in the ServerHello unless the same
    TEXT[!MUST]:    extension type appeared in the corresponding ClientHello.
    TEXT[!MUST]: If a
    TEXT[!MUST]:    client receives an extension type in ServerHello that it did not
    TEXT[!MUST]:    request in the associated ClientHello, it MUST abort the handshake
    TEXT[!MUST]:    with an unsupported_extension fatal alert.
    TEXT[!MAY]:    When multiple extensions of different types are present in the
    TEXT[!MAY]:    ClientHello or ServerHello messages, the extensions MAY appear in any
    TEXT[!MAY]:    order.
    TEXT[!MUST]: There MUST NOT be more than one extension of the same type.
    TEXT[!SHOULD]: Indeed, a client
    TEXT[!SHOULD]:    that requests session resumption does not in general know whether the
    TEXT[!SHOULD]:    server will accept this request, and therefore it SHOULD send the
    TEXT[!SHOULD]:    same extensions as it would send if it were not attempting
    TEXT[!SHOULD]:    resumption.

  SECTION: [Signature Algorithms](#section-7.4.1.4.1)
    TEXT[!MUST]: It MUST NOT appear in this extension.
    TEXT[!MAY]:    If the client supports only the default hash and signature algorithms
    TEXT[!MAY]:    (listed in this section), it MAY omit the signature_algorithms
    TEXT[!MAY]:    extension.
    TEXT[!MUST]: If the client does not support the default algorithms, or
    TEXT[!MUST]:    supports other hash and signature algorithms (and it is willing to
    TEXT[!MUST]:    use them for verifying messages sent by the server, i.e., server
    TEXT[!MUST]:    certificates and server key exchange), it MUST send the
    TEXT[!MUST]:    If the client does not send the signature_algorithms extension, the
    TEXT[!MUST]:    server MUST do the following:
    TEXT[!MUST]:    Clients MUST NOT offer it if they are offering prior versions.
    TEXT[!MUST]:    Servers MUST NOT send this extension.
    TEXT[!MUST]: TLS servers MUST support
    TEXT[!MUST]:    receiving this extension.

  SECTION: [Server Certificate](#section-7.4.2)
    TEXT[!MUST]:       The server MUST send a Certificate message whenever the agreed-
    TEXT[!MUST]:       upon key exchange method uses certificates for authentication
    TEXT[!MUST]:       (this includes all key exchange methods defined in this document
    TEXT[!MUST]:       except DH_anon).
    TEXT[!MUST]:       The certificate MUST be appropriate for the negotiated cipher
    TEXT[!MUST]:       suite's key exchange algorithm and any negotiated extensions.
    TEXT[!MUST]: The sender's
    TEXT[!MUST]:       certificate MUST come first in the list.
    TEXT[!MUST]: Each following
    TEXT[!MUST]:       certificate MUST directly certify the one preceding it.
    TEXT[!MAY]: Because
    TEXT[!MAY]:       certificate validation requires that root keys be distributed
    TEXT[!MAY]:       independently, the self-signed certificate that specifies the root
    TEXT[!MAY]:       certificate authority MAY be omitted from the chain, under the
    TEXT[!MAY]:       assumption that the remote end must already possess it in order to
    TEXT[!MAY]:       validate it in any case.
    TEXT[!MAY]: Note that a client MAY
    TEXT[!MAY]:    send no certificates if it does not have an appropriate certificate
    TEXT[!MAY]:    to send in response to the server's authentication request.
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3, unless explicitly negotiated
    TEXT[!MUST]:       otherwise (e.g., [TLSPGP]).
    TEXT[!MUST]:    -  The end entity certificate's public key (and associated
    TEXT[!MUST]:       restrictions) MUST be compatible with the selected key exchange
    TEXT[!MUST]:       algorithm.
    TEXT[!MUST]:       RSA                RSA public key; the certificate MUST allow the
    TEXT[!MUST]:       RSA_PSK            key to be used for encryption (the
    TEXT[!MUST]:                          keyEncipherment bit MUST be set if the key
    TEXT[!MUST]:                          usage extension is present).
    TEXT[!MUST]:       DHE_RSA            RSA public key; the certificate MUST allow the
    TEXT[!MUST]:       ECDHE_RSA          key to be used for signing (the
    TEXT[!MUST]:                          digitalSignature bit MUST be set if the key
    TEXT[!MUST]:                          usage extension is present) with the signature
    TEXT[!MUST]:                          scheme and hash algorithm that will be employed
    TEXT[!MUST]:                          in the server key exchange message.
    TEXT[!MUST]:       DHE_DSS            DSA public key; the certificate MUST allow the
    TEXT[!MUST]:                          key to be used for signing with the hash
    TEXT[!MUST]:                          algorithm that will be employed in the server
    TEXT[!MUST]:                          key exchange message.
    TEXT[!MUST]:       DH_DSS             Diffie-Hellman public key; the keyAgreement bit
    TEXT[!MUST]:       DH_RSA             MUST be set if the key usage extension is
    TEXT[!MUST]:                          present.
    TEXT[!MUST]:       ECDH_ECDSA         ECDH-capable public key; the public key MUST
    TEXT[!MUST]:       ECDH_RSA           use a curve and point format supported by the
    TEXT[!MUST]:                          client, as described in [TLSECC].
    TEXT[!MUST]:       ECDHE_ECDSA        ECDSA-capable public key; the certificate MUST
    TEXT[!MUST]:                          allow the key to be used for signing with the
    TEXT[!MUST]:                          hash algorithm that will be employed in the
    TEXT[!MUST]:                          server key exchange message.
    TEXT[!MUST]: The public key
    TEXT[!MUST]:                          MUST use a curve and point format supported by
    TEXT[!MUST]:                          the client, as described in  [TLSECC].
    TEXT[!MUST]:    If the client provided a "signature_algorithms" extension, then all
    TEXT[!MUST]:    certificates provided by the server MUST be signed by a
    TEXT[!MUST]:    hash/signature algorithm pair that appears in that extension.
    TEXT[!MAY]: Note
    TEXT[!MAY]:    that this implies that a certificate containing a key for one
    TEXT[!MAY]:    signature algorithm MAY be signed using a different signature
    TEXT[!MAY]:    algorithm (for instance, an RSA key signed with a DSA key).
    TEXT[!MAY]: Fixed DH certificates MAY be
    TEXT[!MAY]:    signed with any hash/signature algorithm pair appearing in the
    TEXT[!MAY]:    extension.
    TEXT[!SHOULD]: If the server has a single certificate, it SHOULD attempt to
    TEXT[!SHOULD]:    validate that it meets these criteria.

  SECTION: [Server Key Exchange Message](#section-7.4.3)
    TEXT[!MUST]:       Other key exchange algorithms, such as those defined in [TLSECC],
    TEXT[!MUST]:       MUST specify whether the ServerKeyExchange message is sent or not;
    TEXT[!MUST]:       and if the message is sent, its contents.
    TEXT[!MUST]:    If the client has offered the "signature_algorithms" extension, the
    TEXT[!MUST]:    signature algorithm and hash algorithm MUST be a pair listed in that
    TEXT[!MUST]:    extension.
    TEXT[!MUST]: In
    TEXT[!MUST]:    order to negotiate correctly, the server MUST check any candidate
    TEXT[!MUST]:    cipher suites against the "signature_algorithms" extension before
    TEXT[!MUST]:    selecting them.
    TEXT[!MUST]:    In addition, the hash and signature algorithms MUST be compatible
    TEXT[!MUST]:    with the key in the server's end-entity certificate.
    TEXT[!MAY]: RSA keys MAY be
    TEXT[!MAY]:    used with any permitted hash algorithm, subject to restrictions in
    TEXT[!MAY]:    the certificate, if any.

  SECTION: [Certificate Request](#section-7.4.4)
    TEXT[!MAY]: If
    TEXT[!MAY]:       the certificate_authorities list is empty, then the client MAY
    TEXT[!MAY]:       send any certificate of the appropriate ClientCertificateType,
    TEXT[!MAY]:       unless there is some external arrangement to the contrary.
    TEXT[!MUST]:    -  Any certificates provided by the client MUST be signed using a
    TEXT[!MUST]:       hash/signature algorithm pair found in
    TEXT[!MUST]:       supported_signature_algorithms.
    TEXT[!MUST]:    -  The end-entity certificate provided by the client MUST contain a
    TEXT[!MUST]:       key that is compatible with certificate_types.
    TEXT[!MUST]: If the key is a
    TEXT[!MUST]:       signature key, it MUST be usable with some hash/signature
    TEXT[!MUST]:       algorithm pair in supported_signature_algorithms.
    TEXT[!MAY]: For
    TEXT[!MAY]:       example, if the server sends dss_fixed_dh certificate type and
    TEXT[!MAY]:       {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply
    TEXT[!MAY]:       with a certificate containing a static DH key, signed with RSA-
    TEXT[!MAY]:       SHA1.

  SECTION: [Server Hello Done](#section-7.4.5)
    TEXT[!SHOULD]:       Upon receipt of the ServerHelloDone message, the client SHOULD
    TEXT[!SHOULD]:       verify that the server provided a valid certificate, if required,
    TEXT[!SHOULD]:       and check that the server hello parameters are acceptable.

  SECTION: [Client Certificate](#section-7.4.6)
    TEXT[!MUST]: If no suitable certificate is available,
    TEXT[!MUST]:       the client MUST send a certificate message containing no
    TEXT[!MUST]:       certificates.
    TEXT[!MAY]: If the client does not send any certificates, the
    TEXT[!MAY]:       server MAY at its discretion either continue the handshake without
    TEXT[!MAY]:       client authentication, or respond with a fatal handshake_failure
    TEXT[!MAY]:       alert.
    TEXT[!MAY]: Also, if some aspect of the certificate chain was
    TEXT[!MAY]:       unacceptable (e.g., it was not signed by a known, trusted CA), the
    TEXT[!MAY]:       server MAY at its discretion either continue the handshake
    TEXT[!MAY]:       (considering the client unauthenticated) or send a fatal alert.
    TEXT[!MUST]: The certificate MUST be appropriate for the negotiated
    TEXT[!MUST]:       cipher suite's key exchange algorithm, and any negotiated
    TEXT[!MUST]:       extensions.
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3, unless explicitly negotiated
    TEXT[!MUST]:       otherwise (e.g., [TLSPGP]).
    TEXT[!MUST]:       rsa_sign            RSA public key; the certificate MUST allow the
    TEXT[!MUST]:                           key to be used for signing with the signature
    TEXT[!MUST]:                           scheme and hash algorithm that will be
    TEXT[!MUST]:                           employed in the certificate verify message.
    TEXT[!MUST]:       dss_sign            DSA public key; the certificate MUST allow the
    TEXT[!MUST]:                           key to be used for signing with the hash
    TEXT[!MUST]:                           algorithm that will be employed in the
    TEXT[!MUST]:                           certificate verify message.
    TEXT[!MUST]:       ecdsa_sign          ECDSA-capable public key; the certificate MUST
    TEXT[!MUST]:                           allow the key to be used for signing with the
    TEXT[!MUST]:                           hash algorithm that will be employed in the
    TEXT[!MUST]:                           certificate verify message; the public key
    TEXT[!MUST]:                           MUST use a curve and point format supported by
    TEXT[!MUST]:                           the server.
    TEXT[!MUST]:       rsa_fixed_dh        Diffie-Hellman public key; MUST use the same
    TEXT[!MUST]:       dss_fixed_dh        parameters as server's key.
    TEXT[!MUST]:       rsa_fixed_ecdh      ECDH-capable public key; MUST use the
    TEXT[!MUST]:       ecdsa_fixed_ecdh    same curve as the server's key, and MUST use a
    TEXT[!MUST]:                           point format supported by the server.
    TEXT[!SHOULD]:    -  If the certificate_authorities list in the certificate request
    TEXT[!SHOULD]:       message was non-empty, one of the certificates in the certificate
    TEXT[!SHOULD]:       chain SHOULD be issued by one of the listed CAs.
    TEXT[!MUST]:    -  The certificates MUST be signed using an acceptable hash/
    TEXT[!MUST]:       signature algorithm pair, as described in Section 7.4.4.

  SECTION: [Client Key Exchange Message](#section-7.4.7)
    TEXT[!MUST]: It MUST immediately
    TEXT[!MUST]:       follow the client certificate message, if it is sent.
    TEXT[!MUST]: Otherwise,
    TEXT[!MUST]:       it MUST be the first message sent by the client after it receives
    TEXT[!MUST]:       the ServerHelloDone message.
    TEXT[!MUST]: If the client is sending a certificate containing a static
    TEXT[!MUST]:       DH exponent (i.e., it is doing fixed_dh client authentication),
    TEXT[!MUST]:       then this message MUST be sent but MUST be empty.

  SECTION: [RSA-Encrypted Premaster Secret Message](#section-7.4.7.1)
    TEXT[!MUST]:    Client implementations MUST always send the correct version number in
    TEXT[!MUST]:    PreMasterSecret.
    TEXT[!MUST]: If ClientHello.client_version is TLS 1.1 or higher,
    TEXT[!MUST]:    server implementations MUST check the version number as described in
    TEXT[!MUST]:    the note below.
    TEXT[!SHOULD]: If the version number is TLS 1.0 or earlier, server
    TEXT[!SHOULD]:    implementations SHOULD check the version number, but MAY have a
    TEXT[!SHOULD]:    configuration option to disable the check.
    TEXT[!SHOULD]: Note that if the check
    TEXT[!SHOULD]:    fails, the PreMasterSecret SHOULD be randomized as described below.
    TEXT[!SHOULD]: [KPR03] describe some theoretical attacks, and therefore
    TEXT[!SHOULD]:    the first construction described is RECOMMENDED.
    TEXT[!MUST]:    In any case, a TLS server MUST NOT generate an alert if processing an
    TEXT[!MUST]:    RSA-encrypted premaster secret message fails, or the version number
    TEXT[!MUST]:    is not as expected.
    TEXT[!MUST]: Instead, it MUST continue the handshake with a
    TEXT[!MUST]:    randomly generated premaster secret.
    TEXT[!MUST]:    upgrading from SSLv3 MUST modify their implementations to generate
    TEXT[!MUST]:    and accept the correct encoding.
    TEXT[!MUST]: Accordingly, implementations that use static RSA keys MUST
    TEXT[!MUST]:    use RSA blinding or some other anti-timing technique, as described in
    TEXT[!MUST]:    [TIMING].

  SECTION: [Client Diffie-Hellman Public Value](#section-7.4.7.2)
    TEXT[!MUST]: In this
    TEXT[!MUST]:          case, the client key exchange message will be sent, but it MUST
    TEXT[!MUST]:          be empty.

  SECTION: [Certificate Verify](#section-7.4.8)
    TEXT[!MUST]: When
    TEXT[!MUST]:       sent, it MUST immediately follow the client key exchange message.
    TEXT[!MUST]:       The hash and signature algorithms used in the signature MUST be
    TEXT[!MUST]:       one of those present in the supported_signature_algorithms field
    TEXT[!MUST]:       of the CertificateRequest message.
    TEXT[!MUST]: In addition, the hash and
    TEXT[!MUST]:       signature algorithms MUST be compatible with the key in the
    TEXT[!MUST]:       client's end-entity certificate.
    TEXT[!MAY]: RSA keys MAY be used with any
    TEXT[!MAY]:       permitted hash algorithm, subject to restrictions in the
    TEXT[!MAY]:       certificate, if any.

  SECTION: [Finished](#section-7.4.9)
    TEXT[!MUST]: Recipients of Finished
    TEXT[!MUST]:       messages MUST verify that the contents are correct.
    TEXT[!MUST]: For the PRF
    TEXT[!MUST]:       defined in Section 5, the Hash MUST be the Hash used as the basis
    TEXT[!MUST]:       for the PRF.
    TEXT[!MUST]: Any cipher suite which defines a different PRF MUST
    TEXT[!MUST]:       also define the Hash to use in the Finished computation.
    TEXT[!MUST]:       Future cipher suites MAY specify other lengths but such length
    TEXT[!MUST]:       MUST be at least 12 bytes.

  SECTION: [Mandatory Cipher Suites](#section-9)
    TEXT[!MUST]:    In the absence of an application profile standard specifying
    TEXT[!MUST]:    otherwise, a TLS-compliant application MUST implement the cipher
    TEXT[!MUST]:    suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the
    TEXT[!MUST]:    definition).

  SECTION: [The Cipher Suite](#appendix-A.5)
    TEXT[!MUST]:    TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a
    TEXT[!MUST]:    TLS connection during the first handshake on that channel, but MUST
    TEXT[!MUST]:    NOT be negotiated, as it provides no more protection than an
    TEXT[!MUST]:    unsecured connection.
    TEXT[!MUST]: Using this mode therefore is of limited use: These
    TEXT[!MUST]:    cipher suites MUST NOT be used by TLS 1.2 implementations unless the
    TEXT[!MUST]:    application layer has specifically requested to allow anonymous key
    TEXT[!MUST]:    exchange.

  SECTION: [Compatibility with TLS 1.0/1.1 and SSL 3.0](#appendix-E.1)
    TEXT[!MUST]:    If the version chosen by the server is not supported by the client
    TEXT[!MUST]:    (or not acceptable), the client MUST send a "protocol_version" alert
    TEXT[!MUST]:    message and close the connection.
    TEXT[!MUST]:    If a TLS server receives a ClientHello containing a version number
    TEXT[!MUST]:    greater than the highest version supported by the server, it MUST
    TEXT[!MUST]:    reply according to the highest version supported by the server.
    TEXT[!MUST]: If server supports (or is
    TEXT[!MUST]:    willing to use) only versions greater than client_version, it MUST
    TEXT[!MUST]:    send a "protocol_version" alert message and close the connection.
    TEXT[!SHOULD]:    Whenever a client already knows the highest protocol version known to
    TEXT[!SHOULD]:    a server (for example, when resuming a session), it SHOULD initiate
    TEXT[!SHOULD]:    the connection in that native protocol.
    TEXT[!MUST]: Thus, TLS servers
    TEXT[!MUST]:    compliant with this specification MUST accept any value {03,XX} as
    TEXT[!MUST]:    the record layer version number for ClientHello.
    TEXT[!MAY]:    TLS clients that wish to negotiate with older servers MAY send any
    TEXT[!MAY]:    value {03,XX} as the record layer version number.

  SECTION: [Compatibility with SSL 2.0](#appendix-E.2)
    TEXT[!MUST]:    TLS 1.2 clients that wish to support SSL 2.0 servers MUST send
    TEXT[!MUST]:    version 2.0 CLIENT-HELLO messages defined in [SSL2].
    TEXT[!MUST]: The message
    TEXT[!MUST]:    MUST contain the same version number as would be used for ordinary
    TEXT[!MUST]:    ClientHello, and MUST encode the supported TLS cipher suites in the
    TEXT[!MUST]:    CIPHER-SPECS-DATA field as described below.
    TEXT[!SHOULD]: TLS 1.2 clients SHOULD NOT support SSL 2.0.
    TEXT[!MAY]:    However, even TLS servers that do not support SSL 2.0 MAY accept
    TEXT[!MAY]:    version 2.0 CLIENT-HELLO messages.
    TEXT[!MUST]: Note that this message MUST be sent directly on the
    TEXT[!MUST]:    wire, not wrapped as a TLS record.
    TEXT[!MUST]:    msg_length
    TEXT[!MUST]:       The highest bit MUST be 1; the remaining bits contain the length
    TEXT[!MUST]:       of the following data in bytes.
    TEXT[!MUST]: The value MUST be 1.
    TEXT[!MUST]: It
    TEXT[!MUST]:       cannot be zero and MUST be a multiple of the V2CipherSpec length
    TEXT[!MUST]:       (3).
    TEXT[!MUST]:    session_id_length
    TEXT[!MUST]:       This field MUST have a value of zero for a client that claims to
    TEXT[!MUST]:       support TLS 1.2.
    TEXT[!SHOULD]: When using the SSLv2 backward-
    TEXT[!SHOULD]:       compatible handshake the client SHOULD use a 32-byte challenge.
    TEXT[!MUST]:    session_id
    TEXT[!MUST]:       This field MUST be empty.
    TEXT[!MUST]:    Note: Requests to resume a TLS session MUST use a TLS client hello.

  SECTION: [Avoiding Man-in-the-Middle Version Rollback](#appendix-E.3)
    TEXT[!MUST]:    When TLS clients fall back to Version 2.0 compatibility mode, they
    TEXT[!MUST]:    MUST use special PKCS#1 block formatting.
    TEXT[!MUST]:    When a client negotiates SSL 2.0 but also supports TLS, it MUST set
    TEXT[!MUST]:    the right-hand (least-significant) 8 random bytes of the PKCS padding
    TEXT[!MUST]:    (not including the terminal null of the padding) for the RSA
    TEXT[!MUST]:    encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY
    TEXT[!MUST]:    to 0x03 (the other padding bytes are random).
    TEXT[!SHOULD]:    When a TLS-capable server negotiates SSL 2.0 it SHOULD, after
    TEXT[!SHOULD]:    decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding
    TEXT[!SHOULD]:    bytes are 0x03.
    TEXT[!SHOULD]: If they are not, the server SHOULD generate a random
    TEXT[!SHOULD]:    value for SECRET-KEY-DATA, and continue the handshake (which will
    TEXT[!SHOULD]:    eventually fail since the keys will not match).

  SECTION: [Diffie-Hellman Key Exchange with Authentication](#appendix-F.1.1.3)
    TEXT[!SHOULD]: Implementations SHOULD follow the
    TEXT[!SHOULD]:    guidelines found in [SUBGROUP].
    TEXT[!SHOULD]: Implementations SHOULD generate a
    TEXT[!SHOULD]:    new X for each handshake when using DHE cipher suites.
    TEXT[!SHOULD]: The client SHOULD also verify that the DH public
    TEXT[!SHOULD]:    exponent appears to be of adequate size.
    TEXT[!MAY]: The server MAY choose
    TEXT[!MAY]:    to assist the client by providing a known group, such as those
    TEXT[!MAY]:    defined in [IKEALG] or [MODP].

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5746
  SECTION: [Client Behavior: Initial Handshake](#section-3.4)
    TEXT[!MUST]:    o  The client MUST include either an empty "renegotiation_info"
    TEXT[!MUST]:       extension, or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV signaling
    TEXT[!MUST]:       cipher suite value in the ClientHello.
    TEXT[!SHOULD]: Including both is NOT
    TEXT[!SHOULD]:       RECOMMENDED.
    TEXT[!MUST]:    o  When a ServerHello is received, the client MUST check if it
    TEXT[!MUST]:       includes the "renegotiation_info" extension:
    TEXT[!MUST]: The client MUST then verify that the length of the
    TEXT[!MUST]:          "renegotiated_connection" field is zero, and if it is not, MUST
    TEXT[!MUST]:          abort the handshake (by sending a fatal handshake_failure
    TEXT[!MUST]:          alert).

  SECTION: [Client Behavior: Secure Renegotiation](#section-3.5)
    TEXT[!MUST]:    o  The client MUST include the "renegotiation_info" extension in the
    TEXT[!MUST]:       ClientHello, containing the saved client_verify_data.
    TEXT[!MUST]: The SCSV
    TEXT[!MUST]:       MUST NOT be included.
    TEXT[!MUST]:    o  When a ServerHello is received, the client MUST verify that the
    TEXT[!MUST]:       "renegotiation_info" extension is present; if it is not, the
    TEXT[!MUST]:       client MUST abort the handshake.
    TEXT[!MUST]:    o  The client MUST then verify that the first half of the
    TEXT[!MUST]:       "renegotiated_connection" field is equal to the saved
    TEXT[!MUST]:       client_verify_data value, and the second half is equal to the
    TEXT[!MUST]:       saved server_verify_data value.
    TEXT[!MUST]: If they are not, the client MUST
    TEXT[!MUST]:       abort the handshake.

  SECTION: [Server Behavior: Initial Handshake](#section-3.6)
    TEXT[!MUST]:    o  When a ClientHello is received, the server MUST check if it
    TEXT[!MUST]:       includes the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.
    TEXT[!MUST]:    o  The server MUST check if the "renegotiation_info" extension is
    TEXT[!MUST]:       included in the ClientHello.
    TEXT[!MUST]: The server MUST then verify
    TEXT[!MUST]:       that the length of the "renegotiated_connection" field is zero,
    TEXT[!MUST]:       and if it is not, MUST abort the handshake.
    TEXT[!MUST]:    o  If the secure_renegotiation flag is set to TRUE, the server MUST
    TEXT[!MUST]:       include an empty "renegotiation_info" extension in the ServerHello
    TEXT[!MUST]:       message.
    TEXT[!MUST]:    TLS servers implementing this specification MUST ignore any unknown
    TEXT[!MUST]:    extensions offered by the client and they MUST accept version numbers
    TEXT[!MUST]:    higher than their highest version number and negotiate the highest
    TEXT[!MUST]:    common version.
    TEXT[!MUST]: TLS implementations MUST
    TEXT[!MUST]:    continue to comply with Section 7.4.1.4 for all other extensions.

  SECTION: [Server Behavior: Secure Renegotiation](#section-3.7)
    TEXT[!MUST]:    o  When a ClientHello is received, the server MUST verify that it
    TEXT[!MUST]:       does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.
    TEXT[!MUST]: If
    TEXT[!MUST]:       the SCSV is present, the server MUST abort the handshake.
    TEXT[!MUST]:    o  The server MUST verify that the "renegotiation_info" extension is
    TEXT[!MUST]:       present; if it is not, the server MUST abort the handshake.
    TEXT[!MUST]:    o  The server MUST verify that the value of the
    TEXT[!MUST]:       "renegotiated_connection" field is equal to the saved
    TEXT[!MUST]:       client_verify_data value; if it is not, the server MUST abort the
    TEXT[!MUST]:       handshake.
    TEXT[!MUST]:    o  The server MUST include a "renegotiation_info" extension
    TEXT[!MUST]:       containing the saved client_verify_data and server_verify_data in
    TEXT[!MUST]:       the ServerHello.

  SECTION: [Client Considerations](#section-4.1)
    TEXT[!MUST]: Such clients MUST
    TEXT[!MUST]:    generate a fatal "handshake_failure" alert prior to terminating the
    TEXT[!MUST]:    connection.

  SECTION: [Client Behavior: Legacy (Insecure) Renegotiation](#section-4.2)
    TEXT[!SHOULD]: It is RECOMMENDED that clients refuse this
    TEXT[!SHOULD]:    renegotiation request.
    TEXT[!MUST]: Clients that do so MUST respond to such
    TEXT[!MUST]:    requests with a "no_renegotiation" alert (RFC 5246 requires this
    TEXT[!MUST]:    alert to be at the "warning" level).
    TEXT[!MUST]: If clients nevertheless choose to renegotiate, they
    TEXT[!MUST]:    MUST behave as described below.
    TEXT[!MUST]:    Clients that choose to renegotiate MUST provide either the
    TEXT[!MUST]:    TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV or "renegotiation_info" in
    TEXT[!MUST]:    their ClientHello.
    TEXT[!SHOULD]: Thus,
    TEXT[!SHOULD]:    it is permitted, though NOT RECOMMENDED, for the client to simply
    TEXT[!SHOULD]:    send the SCSV.
    TEXT[!MUST]:    When the ServerHello is received, the client MUST verify that it does
    TEXT[!MUST]:    not contain the "renegotiation_info" extension.
    TEXT[!MUST]: If it does, the
    TEXT[!MUST]:    client MUST abort the handshake.

  SECTION: [Server Considerations](#section-4.3)
    TEXT[!MUST]:    In order to enable clients to probe, even servers that do not support
    TEXT[!MUST]:    renegotiation MUST implement the minimal version of the extension
    TEXT[!MUST]:    described in this document for initial handshakes, thus signaling
    TEXT[!MUST]:    that they have been upgraded.

  SECTION: [Server Behavior: Legacy (Insecure) Renegotiation](#section-4.4)
    TEXT[!SHOULD]:    It is RECOMMENDED that servers not permit legacy renegotiation.
    TEXT[!MUST]: If
    TEXT[!MUST]:    servers nevertheless do permit it, they MUST follow the requirements
    TEXT[!MUST]:    in this section.
    TEXT[!MUST]:    o  When a ClientHello is received, the server MUST verify that it
    TEXT[!MUST]:       does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.
    TEXT[!MUST]: If
    TEXT[!MUST]:       the SCSV is present, the server MUST abort the handshake.
    TEXT[!MUST]:    o  The server MUST verify that the "renegotiation_info" extension is
    TEXT[!MUST]:       not present; if it is, the server MUST abort the handshake.

  SECTION: [SSLv3](#section-4.5)
    TEXT[!MUST]: Clients
    TEXT[!MUST]:    that support SSLv3 and offer secure renegotiation (either via SCSV or
    TEXT[!MUST]:    "renegotiation_info") MUST accept the "renegotiation_info" extension
    TEXT[!MUST]:    from the server, even if the server version is {0x03, 0x00}, and
    TEXT[!MUST]:    behave as described in this specification.
    TEXT[!MUST]: TLS servers that support
    TEXT[!MUST]:    secure renegotiation and support SSLv3 MUST accept SCSV or the
    TEXT[!MUST]:    "renegotiation_info" extension and respond as described in this
    TEXT[!MUST]:    specification even if the offered client version is {0x03, 0x00}.
    TEXT[!SHOULD]: SSLv3 clients that refuse renegotiation SHOULD use a fatal
    TEXT[!SHOULD]:    handshake_failure alert.

  SECTION: [Security Considerations](#section-5)
    TEXT[!SHOULD]: Servers SHOULD NOT allow
    TEXT[!SHOULD]:    clients to renegotiate without using this extension.
    TEXT[!SHOULD]:    TLS implementations SHOULD provide a mechanism to disable and enable
    TEXT[!SHOULD]:    renegotiation.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5869
  SECTION: [To Skip or not to Skip](#section-3.3)
    TEXT[!SHOULD]: Note, however, that if
    TEXT[!SHOULD]:    the IKM is a Diffie-Hellman value, as in the case of TLS with Diffie-
    TEXT[!SHOULD]:    Hellman, then the extract part SHOULD NOT be skipped.
    TEXT[!SHOULD]: This, however, is
    TEXT[!SHOULD]:    NOT RECOMMENDED, especially because it would omit the use of 'info'
    TEXT[!SHOULD]:    as part of the derivation process (and adding 'info' as an input to
    TEXT[!SHOULD]:    the extract step is not advisable -- see [HKDF-paper]).

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc7627
  SECTION: [The Extended Master Secret](#section-4)
    TEXT[!SHOULD]:    Clients and servers SHOULD NOT accept handshakes that do not use the
    TEXT[!SHOULD]:    extended master secret, especially if they rely on features like
    TEXT[!SHOULD]:    compound authentication that fall into the vulnerable cases described
    TEXT[!SHOULD]:    in Section 6.1.

  SECTION: [Extension Definition](#section-5.1)
    TEXT[!MUST]:    If the client and server agree on this extension and a full handshake
    TEXT[!MUST]:    takes place, both client and server MUST use the extended master
    TEXT[!MUST]:    secret derivation algorithm, as defined in Section 4.

  SECTION: [Client and Server Behavior: Full Handshake](#section-5.2)
    TEXT[!MUST]:    In all handshakes, a client implementing this document MUST send the
    TEXT[!MUST]:    "extended_master_secret" extension in its ClientHello.
    TEXT[!MUST]:    If a server implementing this document receives the
    TEXT[!MUST]:    "extended_master_secret" extension, it MUST include the extension in
    TEXT[!MUST]:    its ServerHello message.
    TEXT[!SHOULD]:    If the server receives a ClientHello without the extension, it SHOULD
    TEXT[!SHOULD]:    abort the handshake if it does not wish to interoperate with legacy
    TEXT[!SHOULD]:    clients.
    TEXT[!MUST]: If it chooses to continue the handshake, then it MUST NOT
    TEXT[!MUST]:    include the extension in the ServerHello.
    TEXT[!SHOULD]:    If a client receives a ServerHello without the extension, it SHOULD
    TEXT[!SHOULD]:    abort the handshake if it does not wish to interoperate with legacy
    TEXT[!SHOULD]:    servers.
    TEXT[!MUST]:    If the client and server choose to continue a full handshake without
    TEXT[!MUST]:    the extension, they MUST use the standard master secret derivation
    TEXT[!MUST]:    for the new session.

  SECTION: [Client and Server Behavior: Abbreviated Handshake](#section-5.3)
    TEXT[!SHOULD]:    The client SHOULD NOT offer an abbreviated handshake to resume a
    TEXT[!SHOULD]:    session that does not use an extended master secret.
    TEXT[!SHOULD]: Instead, it
    TEXT[!SHOULD]:    SHOULD offer a full handshake.
    TEXT[!MUST]:    When offering an abbreviated handshake, the client MUST send the
    TEXT[!MUST]:    "extended_master_secret" extension in its ClientHello.
    TEXT[!MUST]:    o  If the original session did not use the "extended_master_secret"
    TEXT[!MUST]:       extension but the new ClientHello contains the extension, then the
    TEXT[!MUST]:       server MUST NOT perform the abbreviated handshake.
    TEXT[!SHOULD]: Instead, it
    TEXT[!SHOULD]:       SHOULD continue with a full handshake (as described in
    TEXT[!SHOULD]:       Section 5.2) to negotiate a new session.
    TEXT[!MUST]:    o  If the original session used the "extended_master_secret"
    TEXT[!MUST]:       extension but the new ClientHello does not contain it, the server
    TEXT[!MUST]:       MUST abort the abbreviated handshake.
    TEXT[!SHOULD]:    o  If neither the original session nor the new ClientHello uses the
    TEXT[!SHOULD]:       extension, the server SHOULD abort the handshake.
    TEXT[!MUST]:    o  If the new ClientHello contains the extension and the server
    TEXT[!MUST]:       chooses to continue the handshake, then the server MUST include
    TEXT[!MUST]:       the "extended_master_secret" extension in its ServerHello message.
    TEXT[!MUST]:    o  If the original session did not use the "extended_master_secret"
    TEXT[!MUST]:       extension but the new ServerHello contains the extension, the
    TEXT[!MUST]:       client MUST abort the handshake.
    TEXT[!MUST]:    o  If the original session used the extension but the new ServerHello
    TEXT[!MUST]:       does not contain the extension, the client MUST abort the
    TEXT[!MUST]:       handshake.

  SECTION: [Interoperability Considerations](#section-5.4)
    TEXT[!MUST]: Hence, the client or server MUST NOT
    TEXT[!MUST]:    export any key material based on the new master secret for any
    TEXT[!MUST]:    subsequent application-level authentication.
    TEXT[!MUST]: In particular, it MUST
    TEXT[!MUST]:    disable [RFC5705] and any Extensible Authentication Protocol (EAP)
    TEXT[!MUST]:    relying on compound authentication [COMPOUND-AUTH].
    TEXT[!MUST]:    Hence, the client or server MUST NOT use the current handshake's
    TEXT[!MUST]:    "verify_data" for application-level authentication.
    TEXT[!MUST]: In particular,
    TEXT[!MUST]:    the client MUST disable renegotiation and any use of the "tls-unique"
    TEXT[!MUST]:    channel binding [RFC5929] on the current connection.
    TEXT[!MAY]:    If the original session uses an extended master secret but the
    TEXT[!MAY]:    ClientHello or ServerHello in the abbreviated handshake does not
    TEXT[!MAY]:    include the extension, it MAY be safe to continue the abbreviated
    TEXT[!MAY]:    handshake since it is protected by the extended master secret of the
    TEXT[!MAY]:    original session.
    TEXT[!MUST]: Since such situations are unusual and likely
    TEXT[!MUST]:    to be the result of transient or inadvertent misconfigurations, this
    TEXT[!MUST]:    document recommends that the client and server MUST abort such
    TEXT[!MUST]:    handshakes.

  SECTION: [Cryptographic Properties of the Hash Function](#section-6.2)
    TEXT[!SHOULD]: As such, hash functions such as MD5 or
    TEXT[!SHOULD]:    SHA1 are NOT RECOMMENDED.

  SECTION: [No SSL 3.0 Support](#section-6.4)
    TEXT[!SHOULD]: Clients and servers
    TEXT[!SHOULD]:    implementing this document SHOULD refuse SSL 3.0 handshakes.
    TEXT[!MUST]: If they
    TEXT[!MUST]:    choose to support SSL 3.0, the resulting sessions MUST use the legacy
    TEXT[!MUST]:    master secret computation, and the interoperability considerations of
    TEXT[!MUST]:    Section 5.4 apply.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8422
  SECTION: [Key Exchange Algorithm](#section-2)
    TEXT[!SHOULD]: Applications using TLS
    TEXT[!SHOULD]:    with this algorithm SHOULD provide authentication by other means.

  SECTION: [ECDHE_ECDSA](#section-2.1)
    TEXT[!MUST]:    In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA- or
    TEXT[!MUST]:    EdDSA-capable public key.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST be signed with ECDSA or EdDSA using the private key
    TEXT[!MUST]:    corresponding to the public key in the server's Certificate.

  SECTION: [ECDHE_RSA](#section-2.2)
    TEXT[!MUST]:    This key exchange algorithm is the same as ECDHE_ECDSA except that
    TEXT[!MUST]:    the server's certificate MUST contain an RSA public key authorized
    TEXT[!MUST]:    for signing and the signature in the ServerKeyExchange message must
    TEXT[!MUST]:    be computed with the corresponding RSA private key.

  SECTION: [ECDH_anon](#section-2.3)
    TEXT[!MUST]:    In ECDH_anon, the server's Certificate, the CertificateRequest, the
    TEXT[!MUST]:    client's Certificate, and the CertificateVerify messages MUST NOT be
    TEXT[!MUST]:    sent.
    TEXT[!MUST]:    The server MUST send an ephemeral ECDH public key and a specification
    TEXT[!MUST]:    of the corresponding curve in the ServerKeyExchange message.
    TEXT[!MUST]: These
    TEXT[!MUST]:    parameters MUST NOT be signed.

  SECTION: [Client Authentication](#section-3)
    TEXT[!SHOULD]:    If these conditions are not met, the client SHOULD send a client
    TEXT[!SHOULD]:    Certificate message containing no certificates.
    TEXT[!MUST]: In this case, the
    TEXT[!MUST]:    ClientKeyExchange MUST be sent as described in Section 2, and the
    TEXT[!MUST]:    CertificateVerify MUST NOT be sent.

  SECTION: [ECDSA_sign](#section-3.1)
    TEXT[!MUST]:    To use this authentication mechanism, the client MUST possess a
    TEXT[!MUST]:    certificate containing an ECDSA- or EdDSA-capable public key.

  SECTION: [TLS Extensions for ECC](#section-4)
    TEXT[!SHOULD]:    A TLS client that proposes ECC cipher suites in its ClientHello
    TEXT[!SHOULD]:    message SHOULD include these extensions.
    TEXT[!MUST]: Servers implementing ECC
    TEXT[!MUST]:    cipher suites MUST support these extensions, and when a client uses
    TEXT[!MUST]:    these extensions, servers MUST NOT negotiate the use of an ECC cipher
    TEXT[!MUST]:    suite unless they can complete the handshake while respecting the
    TEXT[!MUST]:    choice of curves specified by the client.
    TEXT[!MUST]:    The client MUST NOT include these extensions in the ClientHello
    TEXT[!MUST]:    message if it does not propose any ECC cipher suites.

  SECTION: [Client Hello Extensions](#section-5.1)
    TEXT[!SHOULD]:    The extensions SHOULD be sent along with any ClientHello message that
    TEXT[!SHOULD]:    proposes ECC cipher suites.
    TEXT[!SHOULD]: Clients
    TEXT[!SHOULD]:    SHOULD send both the Supported Elliptic Curves Extension and the
    TEXT[!SHOULD]:    Supported Point Formats Extension.
    TEXT[!MUST]: If the Supported Point Formats
    TEXT[!MUST]:    Extension is indeed sent, it MUST contain the value 0 (uncompressed)
    TEXT[!MUST]:    as one of the items in the list of point formats.
    TEXT[!MUST]:    A server that receives a ClientHello containing one or both of these
    TEXT[!MUST]:    extensions MUST use the client's enumerated capabilities to guide its
    TEXT[!MUST]:    selection of an appropriate cipher suite.
    TEXT[!MUST]: The
    TEXT[!MUST]:    server MUST consider the extensions in both cases.
    TEXT[!MUST]:    If a server does not understand the Supported Elliptic Curves
    TEXT[!MUST]:    Extension, does not understand the Supported Point Formats Extension,
    TEXT[!MUST]:    or is unable to complete the ECC handshake while restricting itself
    TEXT[!MUST]:    to the enumerated curves and point formats, it MUST NOT negotiate the
    TEXT[!MUST]:    use of an ECC cipher suite.

  SECTION: [Supported Point Formats Extension](#section-5.1.2)
    TEXT[!MUST]: Implementations of this document MUST support the
    TEXT[!MUST]:    uncompressed format for all of their supported curves and MUST NOT
    TEXT[!MUST]:    support other formats for curves defined in this specification.
    TEXT[!MAY]: For
    TEXT[!MAY]:    backwards compatibility purposes, the point format list extension MAY
    TEXT[!MAY]:    still be included and contain exactly one value: the uncompressed
    TEXT[!MAY]:    point format (0).
    TEXT[!MUST]:    If the client sends the extension and the extension does not contain
    TEXT[!MUST]:    the uncompressed point format, and the client has used the Supported
    TEXT[!MUST]:    Groups extension to indicate support for any of the curves defined in
    TEXT[!MUST]:    this specification, then the server MUST abort the handshake and
    TEXT[!MUST]:    return an illegal_parameter alert.
    TEXT[!MUST]:    A client compliant with this specification that supports no other
    TEXT[!MUST]:    curves MUST send the following octets; note that the first two octets
    TEXT[!MUST]:    indicate the extension type (Supported Point Formats Extension):

  SECTION: [Server Hello Extension](#section-5.2)
    TEXT[!MAY]: Note
    TEXT[!MAY]:    that the server MAY include items that were not found in the client's
    TEXT[!MAY]:    list.
    TEXT[!MUST]: The Supported
    TEXT[!MUST]:    Point Formats Extension, when used, MUST contain the value 0
    TEXT[!MUST]:    (uncompressed) as one of the items in the list of point formats.
    TEXT[!MUST]:    A client that receives a ServerHello message containing a Supported
    TEXT[!MUST]:    Point Formats Extension MUST respect the server's choice of point
    TEXT[!MUST]:    formats during the handshake (cf.

  SECTION: [Server Certificate](#section-5.3)
    TEXT[!MUST]: ECC
    TEXT[!MUST]:    public keys MUST be encoded in certificates as described in
    TEXT[!MUST]:    Section 5.9.
    TEXT[!MUST]:    +-------------+-----------------------------------------------------+
    TEXT[!MUST]:    | Algorithm   | Server Certificate Type                             |
    TEXT[!MUST]:    +-------------+-----------------------------------------------------+
    TEXT[!MUST]:    | ECDHE_ECDSA | Certificate MUST contain an ECDSA- or EdDSA-capable |
    TEXT[!MUST]:    |             | public key.
    TEXT[!MUST]:    | ECDHE_RSA   | Certificate MUST contain an RSA public key.
    TEXT[!MUST]:    certificate MUST respect the client's choice of elliptic curves.
    TEXT[!MUST]:    server that cannot satisfy this requirement MUST NOT choose an ECC
    TEXT[!MUST]:    cipher suite in its ServerHello message.)

  SECTION: [Server Key Exchange](#section-5.4)
    TEXT[!MUST]: This structure MUST NOT be used with Ed25519 and
    TEXT[!MUST]:    Ed448 public keys.

  SECTION: [Client Certificate](#section-5.6)
    TEXT[!MUST]: The certificate MUST
    TEXT[!MUST]:    contain an ECDSA- or EdDSA-capable public key.

  SECTION: [Elliptic Curve Certificates](#section-5.9)
    TEXT[!MUST]:    X.509 certificates containing ECC public keys or signed using ECDSA
    TEXT[!MUST]:    MUST comply with [RFC3279] or another RFC that replaces or extends
    TEXT[!MUST]:    it.
    TEXT[!MUST]: X.509 certificates containing ECC public keys or signed using
    TEXT[!MUST]:    EdDSA MUST comply with [RFC8410].
    TEXT[!SHOULD]: Clients SHOULD use the elliptic
    TEXT[!SHOULD]:    curve domain parameters recommended in ANSI X9.62, FIPS 186-4, and
    TEXT[!SHOULD]:    SEC 2 [SECG-SEC2], or in [RFC8032].
    TEXT[!MUST]:    EdDSA keys using the Ed25519 algorithm MUST use the ed25519 signature
    TEXT[!MUST]:    algorithm, and Ed448 keys MUST use the ed448 signature algorithm.
    TEXT[!MUST]: Ed25519, Ed25519ph, Ed448, and Ed448ph keys MUST NOT be used
    TEXT[!MUST]:    with ECDSA.

  SECTION: [ECDH, ECDSA, and RSA Computations](#section-5.10)
    TEXT[!MUST]:    Element to Octet String Conversion Primitive), has constant length
    TEXT[!MUST]:    for any given field; leading zeros found in this octet string MUST
    TEXT[!MUST]:    NOT be truncated.
    TEXT[!MUST]:    An ECDHE key exchange using X25519 (curve x25519) goes as follows:
    TEXT[!MUST]:    (1) each party picks a secret key d uniformly at random and computes
    TEXT[!MUST]:    the corresponding public key x = X25519(d, G); (2) parties exchange
    TEXT[!MUST]:    their public keys and compute a shared secret as x_S = X25519(d,
    TEXT[!MUST]:    x_peer); and (3), if either party obtains all-zeroes x_S, it MUST
    TEXT[!MUST]:    abort the handshake (as required by definition of X25519 and X448).
    TEXT[!MUST]:    All ECDSA computations MUST be performed according to ANSI X9.62 or
    TEXT[!MUST]:    its successors.
    TEXT[!MUST]:    A secure hash function such as SHA-256, SHA-384, or SHA-512 from
    TEXT[!MUST]:    [FIPS.180-4] MUST be used.
    TEXT[!MUST]:    All EdDSA computations MUST be performed according to [RFC8032] or
    TEXT[!MUST]:    its successors.
    TEXT[!MUST]: The context parameter for Ed448 MUST be
    TEXT[!MUST]:    set to the empty string.
    TEXT[!MUST]: EdDSA signatures MUST have HashAlgorithm of 8
    TEXT[!MUST]:    (Intrinsic).

  SECTION: [Public Key Validation](#section-5.11)
    TEXT[!MUST]:    With the NIST curves, each party MUST validate the public key sent by
    TEXT[!MUST]:    its peer in the ClientKeyExchange and ServerKeyExchange messages.
    TEXT[!MUST]:    receiving party MUST check that the x and y parameters from the
    TEXT[!MUST]:    peer's public value satisfy the curve equation, y^2 = x^3 + ax + b
    TEXT[!MUST]:    mod p.
    TEXT[!MUST]:    With X25519 and X448, a receiving party MUST check whether the
    TEXT[!MUST]:    computed premaster secret is the all-zero value and abort the
    TEXT[!MUST]:    handshake if so, as described in Section 6 of [RFC7748].

  SECTION: [Cipher Suites](#section-6)
    TEXT[!SHOULD]:    Server implementations SHOULD support all of the following cipher
    TEXT[!SHOULD]:    suites, and client implementations SHOULD support at least one of
    TEXT[!SHOULD]:    them:

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8446
  SECTION: [Protocol Overview](#section-2)
    TEXT[!MUST]: If (EC)DHE key establishment
    TEXT[!MUST]:    is in use, then the ServerHello contains a "key_share" extension with
    TEXT[!MUST]:    the server's ephemeral Diffie-Hellman share; the server's share MUST
    TEXT[!MUST]:    be in the same group as one of the client's shares.
    TEXT[!MUST]:    Application Data MUST NOT be sent prior to sending the Finished
    TEXT[!MUST]:    message, except as specified in Section 2.3.

  SECTION: [Incorrect DHE Share](#section-2.1)
    TEXT[!MUST]: If no
    TEXT[!MUST]:    common cryptographic parameters can be negotiated, the server MUST
    TEXT[!MUST]:    abort the handshake with an appropriate alert.

  SECTION: [Resumption and Pre-Shared Key (PSK)](#section-2.2)
    TEXT[!SHOULD]: When a client offers
    TEXT[!SHOULD]:    resumption via a PSK, it SHOULD also supply a "key_share" extension
    TEXT[!SHOULD]:    to the server to allow the server to decline resumption and fall back
    TEXT[!SHOULD]:    to a full handshake, if needed.
    TEXT[!MUST]:    When PSKs are provisioned out of band, the PSK identity and the KDF
    TEXT[!MUST]:    hash algorithm to be used with the PSK MUST also be provisioned.

  SECTION: [Handshake Protocol](#section-4)
    TEXT[!MUST]:    Protocol messages MUST be sent in the order defined in Section 4.4.1
    TEXT[!MUST]:    and shown in the diagrams in Section 2.
    TEXT[!MUST]: A peer which receives a
    TEXT[!MUST]:    handshake message in an unexpected order MUST abort the handshake
    TEXT[!MUST]:    with an "unexpected_message" alert.

  SECTION: [Cryptographic Negotiation](#section-4.1.1)
    TEXT[!MUST]: If there is no overlap between the received
    TEXT[!MUST]:    "supported_groups" and the groups supported by the server, then the
    TEXT[!MUST]:    server MUST abort the handshake with a "handshake_failure" or an
    TEXT[!MUST]:    "insufficient_security" alert.
    TEXT[!MUST]:    If the server selects a PSK, then it MUST also select a key
    TEXT[!MUST]:    establishment mode from the set indicated by the client's
    TEXT[!MUST]:    "psk_key_exchange_modes" extension (at present, PSK alone or with
    TEXT[!MUST]:    (EC)DHE).
    TEXT[!MUST]:    If the server selects an (EC)DHE group and the client did not offer a
    TEXT[!MUST]:    compatible "key_share" extension in the initial ClientHello, the
    TEXT[!MUST]:    server MUST respond with a HelloRetryRequest (Section 4.1.4) message.
    TEXT[!MUST]:    If the server is unable to negotiate a supported set of parameters
    TEXT[!MUST]:    (i.e., there is no overlap between the client and server parameters),
    TEXT[!MUST]:    it MUST abort the handshake with either a "handshake_failure" or
    TEXT[!MUST]:    "insufficient_security" fatal alert (see Section 6).

  SECTION: [Client Hello](#section-4.1.2)
    TEXT[!MUST,implementation]:    When a client first connects to a server, it is REQUIRED to send the
    TEXT[!MUST,implementation]:    ClientHello as its first TLS message.
    TEXT[!MUST]: In that case, the client MUST send the same
    TEXT[!MUST]:    ClientHello without modification, except as follows:
    TEXT[!MUST]:    Because TLS 1.3 forbids renegotiation, if a server has negotiated
    TEXT[!MUST]:    TLS 1.3 and receives a ClientHello at any other time, it MUST
    TEXT[!MUST]:    terminate the connection with an "unexpected_message" alert.
    TEXT[!MUST]:    If a server established a TLS connection with a previous version of
    TEXT[!MUST]:    TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST
    TEXT[!MUST]:    retain the previous protocol version.
    TEXT[!MUST]: In particular, it MUST NOT
    TEXT[!MUST]:    negotiate TLS 1.3.
    TEXT[implementation]:       struct {
    TEXT[implementation]:           ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    TEXT[implementation]:           Random random;
    TEXT[implementation]:           opaque legacy_session_id<0..32>;
    TEXT[implementation]:           CipherSuite cipher_suites<2..2^16-2>;
    TEXT[implementation]:           opaque legacy_compression_methods<1..2^8-1>;
    TEXT[implementation]:           Extension extensions<8..2^16-1>;
    TEXT[implementation]:       } ClientHello;
    TEXT[implementation]:    legacy_version:  In previous versions of TLS, this field was used for
    TEXT[implementation]:       version negotiation and represented the highest version number
    TEXT[implementation]:       supported by the client.  Experience has shown that many servers
    TEXT[implementation]:       do not properly implement version negotiation, leading to "version
    TEXT[implementation]:       intolerance" in which the server rejects an otherwise acceptable
    TEXT[implementation]:       ClientHello with a version number higher than it supports.
    TEXT[!MUST,implementation]: In
    TEXT[!MUST,implementation]:       TLS 1.3, the client indicates its version preferences in the
    TEXT[!MUST,implementation]:       "supported_versions" extension (Section 4.2.1) and the
    TEXT[!MUST,implementation]:       legacy_version field MUST be set to 0x0303, which is the version
    TEXT[!MUST,implementation]:       number for TLS 1.2.
    TEXT[implementation]:   TLS 1.3 ClientHellos are identified as having
    TEXT[implementation]:       a legacy_version of 0x0303 and a supported_versions extension
    TEXT[implementation]:       present with 0x0304 as the highest version indicated therein.
    TEXT[implementation]:       (See Appendix D for details about backward compatibility.)
    TEXT[implementation]:    random:  32 bytes generated by a secure random number generator.  See
    TEXT[implementation]:       Appendix C for additional information.
    TEXT[implementation]:    legacy_session_id:  Versions of TLS before TLS 1.3 supported a
    TEXT[implementation]:       "session resumption" feature which has been merged with pre-shared
    TEXT[implementation]:       keys in this version (see Section 2.2).
    TEXT[!SHOULD,implementation]: A client which has a
    TEXT[!SHOULD,implementation]:       cached session ID set by a pre-TLS 1.3 server SHOULD set this
    TEXT[!SHOULD,implementation]:       field to that value.
    TEXT[!MUST,implementation]: In compatibility mode (see Appendix D.4),
    TEXT[!MUST,implementation]:       this field MUST be non-empty, so a client not offering a
    TEXT[!MUST,implementation]:       pre-TLS 1.3 session MUST generate a new 32-byte value.
    TEXT[!SHOULD,implementation]: This value
    TEXT[!SHOULD,implementation]:       need not be random but SHOULD be unpredictable to avoid
    TEXT[!SHOULD,implementation]:       implementations fixating on a specific value (also known as
    TEXT[!SHOULD,implementation]:       ossification).
    TEXT[!MUST,implementation]: Otherwise, it MUST be set as a zero-length vector
    TEXT[!MUST,implementation]:       (i.e., a zero-valued single byte length field).
    TEXT[!MUST]: If the list contains cipher suites that the server
    TEXT[!MUST]:       does not recognize, support, or wish to use, the server MUST
    TEXT[!MUST]:       ignore those cipher suites and process the remaining ones as
    TEXT[!MUST]:       usual.
    TEXT[!SHOULD]: If the client is attempting a PSK key establishment, it
    TEXT[!SHOULD]:       SHOULD advertise at least one cipher suite indicating a Hash
    TEXT[!SHOULD]:       associated with the PSK.
    TEXT[!MUST]: For every TLS 1.3 ClientHello, this vector
    TEXT[!MUST]:       MUST contain exactly one byte, set to zero, which corresponds to
    TEXT[!MUST]:       the "null" compression method in prior versions of TLS.
    TEXT[!MUST]: If a
    TEXT[!MUST]:       TLS 1.3 ClientHello is received with any other value in this
    TEXT[!MUST]:       field, the server MUST abort the handshake with an
    TEXT[!MUST]:       "illegal_parameter" alert.
    TEXT[!MUST]: Note that TLS 1.3 servers might
    TEXT[!MUST]:       receive TLS 1.2 or prior ClientHellos which contain other
    TEXT[!MUST]:       compression methods and (if negotiating such a prior version) MUST
    TEXT[!MUST]:       follow the procedures for the appropriate prior version of TLS.
    TEXT[!MUST]: Servers MUST ignore unrecognized extensions.
    TEXT[!MUST]: If negotiating a version of TLS prior to 1.3,
    TEXT[!MUST]:    a server MUST check that the message either contains no data after
    TEXT[!MUST]:    legacy_compression_methods or that it contains a valid extensions
    TEXT[!MUST]:    block with no data following.
    TEXT[!MUST]: If not, then it MUST abort the
    TEXT[!MUST]:    handshake with a "decode_error" alert.
    TEXT[!MAY]:    In the event that a client requests additional functionality using
    TEXT[!MAY]:    extensions and this functionality is not supplied by the server, the
    TEXT[!MAY]:    client MAY abort the handshake.

  SECTION: [Server Hello](#section-4.1.3)
    TEXT[!MUST]: In TLS 1.3, the TLS server indicates
    TEXT[!MUST]:       its version using the "supported_versions" extension
    TEXT[!MUST]:       (Section 4.2.1), and the legacy_version field MUST be set to
    TEXT[!MUST]:       0x0303, which is the version number for TLS 1.2.
    TEXT[!MUST]: The last 8 bytes MUST be
    TEXT[!MUST]:       overwritten as described below if negotiating TLS 1.2 or TLS 1.1,
    TEXT[!MUST]:       but the remaining bytes MUST be random.
    TEXT[!MUST]: This structure is
    TEXT[!MUST]:       generated by the server and MUST be generated independently of the
    TEXT[!MUST]:       ClientHello.random.
    TEXT[!MUST]: A client which
    TEXT[!MUST]:       receives a legacy_session_id_echo field that does not match what
    TEXT[!MUST]:       it sent in the ClientHello MUST abort the handshake with an
    TEXT[!MUST]:       "illegal_parameter" alert.
    TEXT[!MUST]: A client which receives a
    TEXT[!MUST]:       cipher suite that was not offered MUST abort the handshake with an
    TEXT[!MUST]:       "illegal_parameter" alert.
    TEXT[!MUST]:    legacy_compression_method:  A single byte which MUST have the
    TEXT[!MUST]:       value 0.
    TEXT[!MUST]: The ServerHello MUST only include
    TEXT[!MUST]:       extensions which are required to establish the cryptographic
    TEXT[!MUST]:       context and negotiate the protocol version.
    TEXT[!MUST]: All TLS 1.3
    TEXT[!MUST]:       ServerHello messages MUST contain the "supported_versions"
    TEXT[!MUST]:       extension.
    TEXT[!MUST]:    Upon receiving a message with type server_hello, implementations MUST
    TEXT[!MUST]:    first examine the Random value and, if it matches this value, process
    TEXT[!MUST]:    it as described in Section 4.1.4).
    TEXT[!MUST]: TLS 1.3 servers which negotiate TLS 1.2 or below in
    TEXT[!MUST]:    response to a ClientHello MUST set the last 8 bytes of their Random
    TEXT[!MUST]:    value specially in their ServerHello.
    TEXT[!MUST]:    If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of
    TEXT[!MUST]:    their Random value to the bytes:
    TEXT[!MUST]:    If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2
    TEXT[!MUST]:    servers SHOULD, set the last 8 bytes of their ServerHello.Random
    TEXT[!MUST]:    value to the bytes:
    TEXT[!MUST]:    TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below
    TEXT[!MUST]:    MUST check that the last 8 bytes are not equal to either of these
    TEXT[!MUST]:    values.
    TEXT[!SHOULD]: TLS 1.2 clients SHOULD also check that the last 8 bytes are
    TEXT[!SHOULD]:    not equal to the second value if the ServerHello indicates TLS 1.1 or
    TEXT[!SHOULD]:    below.
    TEXT[!MUST]: If a match is found, the client MUST abort the handshake with
    TEXT[!MUST]:    an "illegal_parameter" alert.
    TEXT[!MUST]:    A legacy TLS client performing renegotiation with TLS 1.2 or prior
    TEXT[!MUST]:    and which receives a TLS 1.3 ServerHello during renegotiation MUST
    TEXT[!MUST]:    abort the handshake with a "protocol_version" alert.

  SECTION: [Hello Retry Request](#section-4.1.4)
    TEXT[!MUST]:    The server's extensions MUST contain "supported_versions".
    TEXT[!SHOULD]:    Additionally, it SHOULD contain the minimal set of extensions
    TEXT[!SHOULD]:    necessary for the client to generate a correct ClientHello pair.
    TEXT[!MUST]: As
    TEXT[!MUST]:    with the ServerHello, a HelloRetryRequest MUST NOT contain any
    TEXT[!MUST]:    extensions that were not first offered by the client in its
    TEXT[!MUST]:    ClientHello, with the exception of optionally the "cookie" (see
    TEXT[!MUST]:    Section 4.2.2) extension.
    TEXT[!MUST]:    Upon receipt of a HelloRetryRequest, the client MUST check the
    TEXT[!MUST]:    legacy_version, legacy_session_id_echo, cipher_suite, and
    TEXT[!MUST]:    legacy_compression_method as specified in Section 4.1.3 and then
    TEXT[!MUST]:    process the extensions, starting with determining the version using
    TEXT[!MUST]:    "supported_versions".
    TEXT[!MUST]: Clients MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert if the HelloRetryRequest would not result
    TEXT[!MUST]:    in any change in the ClientHello.
    TEXT[!MUST]: If a client receives a second
    TEXT[!MUST]:    HelloRetryRequest in the same connection (i.e., where the ClientHello
    TEXT[!MUST]:    was itself in response to a HelloRetryRequest), it MUST abort the
    TEXT[!MUST]:    handshake with an "unexpected_message" alert.
    TEXT[!MUST]:    Otherwise, the client MUST process all extensions in the
    TEXT[!MUST]:    HelloRetryRequest and send a second updated ClientHello.
    TEXT[!MUST]:    A client which receives a cipher suite that was not offered MUST
    TEXT[!MUST]:    abort the handshake.
    TEXT[!MUST]: Servers MUST ensure that they negotiate the
    TEXT[!MUST]:    same cipher suite when receiving a conformant updated ClientHello (if
    TEXT[!MUST]:    the server selects the cipher suite as the first step in the
    TEXT[!MUST]:    negotiation, then this will happen automatically).
    TEXT[!MUST]: Upon receiving
    TEXT[!MUST]:    the ServerHello, clients MUST check that the cipher suite supplied in
    TEXT[!MUST]:    the ServerHello is the same as that in the HelloRetryRequest and
    TEXT[!MUST]:    otherwise abort the handshake with an "illegal_parameter" alert.
    TEXT[!SHOULD]:    In addition, in its updated ClientHello, the client SHOULD NOT offer
    TEXT[!SHOULD]:    any pre-shared keys associated with a hash other than that of the
    TEXT[!SHOULD]:    selected cipher suite.
    TEXT[!MUST]:    The value of selected_version in the HelloRetryRequest
    TEXT[!MUST]:    "supported_versions" extension MUST be retained in the ServerHello,
    TEXT[!MUST]:    and a client MUST abort the handshake with an "illegal_parameter"
    TEXT[!MUST]:    alert if the value changes.

  SECTION: [Extensions](#section-4.2)
    TEXT[!MAY]: The server sends extension requests in the
    TEXT[!MAY]:    CertificateRequest message which a client MAY respond to with a
    TEXT[!MAY]:    Certificate message.
    TEXT[!MAY]: The server MAY also send unsolicited extensions
    TEXT[!MAY]:    in the NewSessionTicket, though the client does not respond directly
    TEXT[!MAY]:    to these.
    TEXT[!MUST]:    Implementations MUST NOT send extension responses if the remote
    TEXT[!MUST]:    endpoint did not send the corresponding extension requests, with the
    TEXT[!MUST]:    exception of the "cookie" extension in the HelloRetryRequest.
    TEXT[!MUST]: Upon
    TEXT[!MUST]:    receiving such an extension, an endpoint MUST abort the handshake
    TEXT[!MUST]:    with an "unsupported_extension" alert.
    TEXT[!MUST]: If an implementation receives an extension
    TEXT[!MUST]:    which it recognizes and which is not specified for the message in
    TEXT[!MUST]:    which it appears, it MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert.
    TEXT[!MUST]:    When multiple extensions of different types are present, the
    TEXT[!MUST]:    extensions MAY appear in any order, with the exception of
    TEXT[!MUST]:    "pre_shared_key" (Section 4.2.11) which MUST be the last extension in
    TEXT[!MUST]:    the ClientHello (but can appear anywhere in the ServerHello
    TEXT[!MUST]:    extensions block).
    TEXT[!MUST]: There MUST NOT be more than one extension of the
    TEXT[!MUST]:    same type in a given extension block.

  SECTION: [Supported Versions](#section-4.2.1)
    TEXT[!MUST]:    Implementations of this specification MUST send this extension in the
    TEXT[!MUST]:    ClientHello containing all versions of TLS which they are prepared to
    TEXT[!MUST]:    negotiate (for this specification, that means minimally 0x0304, but
    TEXT[!MUST]:    if previous versions of TLS are allowed to be negotiated, they MUST
    TEXT[!MUST]:    be present as well).
    TEXT[!MUST]:    If this extension is not present, servers which are compliant with
    TEXT[!MUST]:    this specification and which also support TLS 1.2 MUST negotiate
    TEXT[!MUST]:    TLS 1.2 or prior as specified in [RFC5246], even if
    TEXT[!MUST]:    ClientHello.legacy_version is 0x0304 or later.
    TEXT[!MAY]: Servers MAY abort the
    TEXT[!MAY]:    handshake upon receiving a ClientHello with legacy_version 0x0304 or
    TEXT[!MAY]:    later.
    TEXT[!MUST]:    If this extension is present in the ClientHello, servers MUST NOT use
    TEXT[!MUST]:    the ClientHello.legacy_version value for version negotiation and MUST
    TEXT[!MUST]:    use only the "supported_versions" extension to determine client
    TEXT[!MUST]:    preferences.
    TEXT[!MUST]: Servers MUST only select a version of TLS present in
    TEXT[!MUST]:    that extension and MUST ignore any unknown versions that are present
    TEXT[!MUST]:    in that extension.
    TEXT[!SHOULD]: Implementations of TLS 1.3 which choose to support prior
    TEXT[!SHOULD]:    versions of TLS SHOULD support TLS 1.2.
    TEXT[!MUST]: Servers MUST be prepared to
    TEXT[!MUST]:    receive ClientHellos that include this extension but do not include
    TEXT[!MUST]:    0x0304 in the list of versions.
    TEXT[!MUST]:    A server which negotiates a version of TLS prior to TLS 1.3 MUST set
    TEXT[!MUST]:    ServerHello.version and MUST NOT send the "supported_versions"
    TEXT[!MUST]:    extension.
    TEXT[!MUST]: A server which negotiates TLS 1.3 MUST respond by sending
    TEXT[!MUST]:    a "supported_versions" extension containing the selected version
    TEXT[!MUST]:    value (0x0304).
    TEXT[!MUST]: It MUST set the ServerHello.legacy_version field to
    TEXT[!MUST]:    0x0303 (TLS 1.2).
    TEXT[!MUST]: Clients MUST check for this extension prior to
    TEXT[!MUST]:    processing the rest of the ServerHello (although they will have to
    TEXT[!MUST]: If this
    TEXT[!MUST]:    extension is present, clients MUST ignore the
    TEXT[!MUST]:    ServerHello.legacy_version value and MUST use only the
    TEXT[!MUST]:    "supported_versions" extension to determine the selected version.
    TEXT[!MUST]: If
    TEXT[!MUST]:    the "supported_versions" extension in the ServerHello contains a
    TEXT[!MUST]:    version not offered by the client or contains a version prior to
    TEXT[!MUST]:    TLS 1.3, the client MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert.

  SECTION: [Cookie](#section-4.2.2)
    TEXT[!MAY]:    When sending a HelloRetryRequest, the server MAY provide a "cookie"
    TEXT[!MAY]:    extension to the client (this is an exception to the usual rule that
    TEXT[!MAY]:    the only extensions that may be sent are those that appear in the
    TEXT[!MAY]:    ClientHello).
    TEXT[!MUST]: When sending the new ClientHello, the client MUST copy
    TEXT[!MUST]:    the contents of the extension received in the HelloRetryRequest into
    TEXT[!MUST]:    a "cookie" extension in the new ClientHello.
    TEXT[!MUST]: Clients MUST NOT use
    TEXT[!MUST]:    cookies in their initial ClientHello in subsequent connections.
    TEXT[!MUST]: Servers operating statelessly MUST ignore these records.

  SECTION: [Signature Algorithms](#section-4.2.3)
    TEXT[!MUST]: The keys found in certificates MUST also
    TEXT[!MUST]:    be of appropriate type for the signature algorithms they are used
    TEXT[!MUST]:    with.
    TEXT[!MUST]: Clients which desire the
    TEXT[!MUST]:    server to authenticate itself via a certificate MUST send the
    TEXT[!MUST]:    "signature_algorithms" extension.
    TEXT[!MUST]: If a server is authenticating via
    TEXT[!MUST]:    a certificate and the client has not sent a "signature_algorithms"
    TEXT[!MUST]:    extension, then the server MUST abort the handshake with a
    TEXT[!MUST]:    "missing_extension" alert (see Section 9.2).
    TEXT[!SHOULD]:    TLS 1.2 implementations SHOULD also process this extension.
    TEXT[!MAY]:    Implementations which have the same policy in both cases MAY omit the
    TEXT[!MAY]:    "signature_algorithms_cert" extension.
    TEXT[!MAY]: These values refer solely to signatures
    TEXT[!MAY]:       which appear in certificates (see Section 4.4.2.2) and are not
    TEXT[!MAY]:       defined for use in signed TLS handshake messages, although they
    TEXT[!MAY]:       MAY appear in "signature_algorithms" and
    TEXT[!MAY]:       "signature_algorithms_cert" for backward compatibility with
    TEXT[!MAY]:       TLS 1.2.
    TEXT[!MUST]:       The length of the Salt MUST be equal to the length of the output
    TEXT[!MUST]:       of the digest algorithm.
    TEXT[!MUST]: If the public key is carried in an X.509
    TEXT[!MUST]:       certificate, it MUST use the rsaEncryption OID [RFC5280].
    TEXT[!MUST]:       The length of the Salt MUST be equal to the length of the digest
    TEXT[!MUST]:       algorithm.
    TEXT[!MUST]: If the public key is carried in an X.509 certificate,
    TEXT[!MUST]:       it MUST use the RSASSA-PSS OID [RFC5756].
    TEXT[!MUST]: When used in
    TEXT[!MUST]:       certificate signatures, the algorithm parameters MUST be DER
    TEXT[!MUST]:       encoded.
    TEXT[!MUST]: If the corresponding public key's parameters are
    TEXT[!MUST]:       present, then the parameters in the signature MUST be identical to
    TEXT[!MUST]:       those in the public key.
    TEXT[!SHOULD]: Endpoints SHOULD NOT negotiate these algorithms but are
    TEXT[!SHOULD]:       permitted to do so solely for backward compatibility.
    TEXT[!MUST]: Clients
    TEXT[!MUST]:       offering these values MUST list them as the lowest priority
    TEXT[!MUST]:       (listed after all other algorithms in SignatureSchemeList).
    TEXT[!MUST]:       TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless
    TEXT[!MUST]:       no valid certificate chain can be produced without it (see
    TEXT[!MUST]:       Section 4.4.2.2).
    TEXT[!MAY]: A certificate that
    TEXT[!MAY]:    begins a certification path MAY use a signature algorithm that is not
    TEXT[!MAY]:    advertised as being supported in the "signature_algorithms"
    TEXT[!MAY]:    extension.
    TEXT[!MUST]: TLS 1.3
    TEXT[!MUST]:    implementations willing to negotiate TLS 1.2 MUST behave in
    TEXT[!MUST]:    accordance with the requirements of [RFC5246] when negotiating that
    TEXT[!MUST]:    version.
    TEXT[!MAY]:    -  TLS 1.2 ClientHellos MAY omit this extension.
    TEXT[!MUST]: They MUST NOT be offered or negotiated by any
    TEXT[!MUST]:       implementation.
    TEXT[!MUST]: In particular, MD5 [SLOTH], SHA-224, and DSA
    TEXT[!MUST]:       MUST NOT be used.
    TEXT[!MUST]: If TLS 1.2 is negotiated, implementations MUST be prepared
    TEXT[!MUST]:       to accept a signature that uses any curve that they advertised in
    TEXT[!MUST]:       the "supported_groups" extension.
    TEXT[!MUST]:    -  Implementations that advertise support for RSASSA-PSS (which is
    TEXT[!MUST]:       mandatory in TLS 1.3) MUST be prepared to accept a signature using
    TEXT[!MUST]:       that scheme even when TLS 1.2 is negotiated.

  SECTION: [Certificate Authorities](#section-4.2.4)
    TEXT[!SHOULD]:    The "certificate_authorities" extension is used to indicate the
    TEXT[!SHOULD]:    certificate authorities (CAs) which an endpoint supports and which
    TEXT[!SHOULD]:    SHOULD be used by the receiving endpoint to guide certificate
    TEXT[!SHOULD]:    selection.
    TEXT[!MAY]:    The client MAY send the "certificate_authorities" extension in the
    TEXT[!MAY]:    ClientHello message.
    TEXT[!MAY]: The server MAY send it in the
    TEXT[!MAY]:    CertificateRequest message.

  SECTION: [OID Filters](#section-4.2.5)
    TEXT[!MUST]: This extension, if provided by the server, MUST only be sent
    TEXT[!MUST]:    in the CertificateRequest message.
    TEXT[!MUST]: If the server has included a non-empty
    TEXT[!MUST]:       filters list, the client certificate included in the response MUST
    TEXT[!MUST]:       contain all of the specified extension OIDs that the client
    TEXT[!MUST]:       recognizes.
    TEXT[!MUST]: For each extension OID recognized by the client, all
    TEXT[!MUST]:       of the specified values MUST be present in the client certificate
    TEXT[!MUST]:       (but the certificate MAY have other values as well).
    TEXT[!MUST]: However, the
    TEXT[!MUST]:       client MUST ignore and skip any unrecognized certificate extension
    TEXT[!MUST]:       OIDs.
    TEXT[!MAY]: If the client ignored some of the required certificate
    TEXT[!MAY]:       extension OIDs and supplied a certificate that does not satisfy
    TEXT[!MAY]:       the request, the server MAY at its discretion either continue the
    TEXT[!MAY]:       connection without client authentication or abort the handshake
    TEXT[!MAY]:       with an "unsupported_certificate" alert.
    TEXT[!MUST]: Any given OID MUST NOT
    TEXT[!MUST]:       appear more than once in the filters list.
    TEXT[!MUST]: The
    TEXT[!MUST]:       special anyExtendedKeyUsage OID MUST NOT be used in the request.

  SECTION: [Post-Handshake Client Authentication](#section-4.2.6)
    TEXT[!MUST]:    Servers MUST NOT send a post-handshake CertificateRequest to clients
    TEXT[!MUST]:    which do not offer this extension.
    TEXT[!MUST]: Servers MUST NOT send this
    TEXT[!MUST]:    extension.

  SECTION: [Supported Groups](#section-4.2.7)
    TEXT[!MUST]: Clients MUST NOT act upon any information
    TEXT[!MUST]:    found in "supported_groups" prior to successful completion of the
    TEXT[!MUST]:    handshake but MAY use the information learned from a successfully
    TEXT[!MUST]:    completed handshake to change what groups they use in their
    TEXT[!MUST]:    "key_share" extension in subsequent connections.
    TEXT[!SHOULD]: If the server has a
    TEXT[!SHOULD]:    group it prefers to the ones in the "key_share" extension but is
    TEXT[!SHOULD]:    still willing to accept the ClientHello, it SHOULD send
    TEXT[!SHOULD]:    "supported_groups" to update the client's view of its preferences;
    TEXT[!SHOULD]:    this extension SHOULD contain all groups the server supports,
    TEXT[!SHOULD]:    regardless of whether they are currently supported by the client.

  SECTION: [Key Share](#section-4.2.8)
    TEXT[!MAY]:    Clients MAY send an empty client_shares vector in order to request
    TEXT[!MAY]:    group selection from the server, at the cost of an additional round
    TEXT[!MAY]:    trip (see Section 4.1.4).
    TEXT[!MAY]:    This vector MAY be empty if the client is requesting a
    TEXT[!MAY]:    HelloRetryRequest.
    TEXT[!MUST]: Each KeyShareEntry value MUST correspond to a
    TEXT[!MUST]:    group offered in the "supported_groups" extension and MUST appear in
    TEXT[!MUST]:    the same order.
    TEXT[!MAY]: However, the values MAY be a non-contiguous subset
    TEXT[!MAY]:    of the "supported_groups" extension and MAY omit the most preferred
    TEXT[!MAY]:    groups.
    TEXT[!MUST]: The
    TEXT[!MUST]:    key_exchange values for each KeyShareEntry MUST be generated
    TEXT[!MUST]:    independently.
    TEXT[!MUST]: Clients MUST NOT offer multiple KeyShareEntry values
    TEXT[!MUST]:    for the same group.
    TEXT[!MUST]: Clients MUST NOT offer any KeyShareEntry values
    TEXT[!MUST]:    for groups not listed in the client's "supported_groups" extension.
    TEXT[!MAY]:    Servers MAY check for violations of these rules and abort the
    TEXT[!MAY]:    handshake with an "illegal_parameter" alert if one is violated.
    TEXT[!MUST]:    Upon receipt of this extension in a HelloRetryRequest, the client
    TEXT[!MUST]:    MUST verify that (1) the selected_group field corresponds to a group
    TEXT[!MUST]:    which was provided in the "supported_groups" extension in the
    TEXT[!MUST]:    original ClientHello and (2) the selected_group field does not
    TEXT[!MUST]:    correspond to a group which was provided in the "key_share" extension
    TEXT[!MUST]:    in the original ClientHello.
    TEXT[!MUST]: If either of these checks fails, then
    TEXT[!MUST]:    the client MUST abort the handshake with an "illegal_parameter"
    TEXT[!MUST]:    alert.
    TEXT[!MUST]: Otherwise, when sending the new ClientHello, the client MUST
    TEXT[!MUST]: This value MUST be in the same
    TEXT[!MUST]:    group as the KeyShareEntry value offered by the client that the
    TEXT[!MUST]:    server has selected for the negotiated key exchange.
    TEXT[!MUST]: Servers
    TEXT[!MUST]:    MUST NOT send a KeyShareEntry for any group not indicated in the
    TEXT[!MUST]:    client's "supported_groups" extension and MUST NOT send a
    TEXT[!MUST]:    KeyShareEntry when using the "psk_ke" PskKeyExchangeMode.
    TEXT[!MUST]: If using
    TEXT[!MUST]:    (EC)DHE key establishment and a HelloRetryRequest containing a
    TEXT[!MUST]:    "key_share" extension was received by the client, the client MUST
    TEXT[!MUST]:    verify that the selected NamedGroup in the ServerHello is the same as
    TEXT[!MUST]:    that in the HelloRetryRequest.
    TEXT[!MUST]: If this check fails, the client MUST
    TEXT[!MUST]:    abort the handshake with an "illegal_parameter" alert.

  SECTION: [Diffie-Hellman Parameters](#section-4.2.8.1)
    TEXT[!MUST]:    Peers MUST validate each other's public key Y by ensuring that 1 < Y
    TEXT[!MUST]:    < p-1.

  SECTION: [ECDHE Parameters](#section-4.2.8.2)
    TEXT[!MUST]:    For the curves secp256r1, secp384r1, and secp521r1, peers MUST
    TEXT[!MUST]:    validate each other's public value Q by ensuring that the point is a
    TEXT[!MUST]:    valid point on the elliptic curve.

  SECTION: [Pre-Shared Key Exchange Modes](#section-4.2.9)
    TEXT[!MUST]:    In order to use PSKs, clients MUST also send a
    TEXT[!MUST]:    "psk_key_exchange_modes" extension.
    TEXT[!MUST]:    A client MUST provide a "psk_key_exchange_modes" extension if it
    TEXT[!MUST]:    offers a "pre_shared_key" extension.
    TEXT[!MUST]: If clients offer
    TEXT[!MUST]:    "pre_shared_key" without a "psk_key_exchange_modes" extension,
    TEXT[!MUST]:    servers MUST abort the handshake.
    TEXT[!MUST]: Servers MUST NOT select a key
    TEXT[!MUST]:    exchange mode that is not listed by the client.
    TEXT[!SHOULD]: Servers SHOULD NOT
    TEXT[!SHOULD]:    send NewSessionTicket with tickets that are not compatible with the
    TEXT[!SHOULD]:    advertised modes; however, if a server does so, the impact will just
    TEXT[!SHOULD]:    be that the client's attempts at resumption fail.
    TEXT[!MUST]:    The server MUST NOT send a "psk_key_exchange_modes" extension.
    TEXT[!MUST]: In this mode, the server
    TEXT[!MUST]:       MUST NOT supply a "key_share" value.
    TEXT[!MUST]: In this mode, the
    TEXT[!MUST]:       client and server MUST supply "key_share" values as described in
    TEXT[!MUST]:       Section 4.2.8.

  SECTION: [Early Data Indication](#section-4.2.10)
    TEXT[!MUST]: If the
    TEXT[!MUST]:    client opts to do so, it MUST supply both the "pre_shared_key" and
    TEXT[!MUST]:    "early_data" extensions.
    TEXT[!MUST]: The PSK used to encrypt the
    TEXT[!MUST]:    early data MUST be the first PSK listed in the client's
    TEXT[!MUST]:    "pre_shared_key" extension.
    TEXT[!MUST]:    For PSKs provisioned via NewSessionTicket, a server MUST validate
    TEXT[!MUST]:    that the ticket age for the selected PSK identity (computed by
    TEXT[!MUST]:    subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age
    TEXT[!MUST]:    modulo 2^32) is within a small tolerance of the time since the ticket
    TEXT[!MUST]:    was issued (see Section 8).
    TEXT[!SHOULD]: If it is not, the server SHOULD proceed
    TEXT[!SHOULD]:    with the handshake but reject 0-RTT, and SHOULD NOT take any other
    TEXT[!SHOULD]:    action that assumes that this ClientHello is fresh.
    TEXT[!MUST]:    A server which receives an "early_data" extension MUST behave in one
    TEXT[!MUST]:    of three ways:
    TEXT[!MUST]: A client MUST NOT include the
    TEXT[!MUST]:       "early_data" extension in its followup ClientHello.
    TEXT[!MUST]:    In order to accept early data, the server MUST have accepted a PSK
    TEXT[!MUST]:    cipher suite and selected the first key offered in the client's
    TEXT[!MUST]:    "pre_shared_key" extension.
    TEXT[!MUST]: In addition, it MUST verify that the
    TEXT[!MUST]:    following values are the same as those associated with the
    TEXT[!MUST]:    selected PSK:
    TEXT[!MUST]:    Future extensions MUST define their interaction with 0-RTT.
    TEXT[!MUST]:    If any of these checks fail, the server MUST NOT respond with the
    TEXT[!MUST]:    extension and must discard all the first-flight data using one of the
    TEXT[!MUST]:    first two mechanisms listed above (thus falling back to 1-RTT or
    TEXT[!MUST]:    2-RTT).
    TEXT[!MUST]:    If the server chooses to accept the "early_data" extension, then it
    TEXT[!MUST]:    MUST comply with the same error-handling requirements specified for
    TEXT[!MUST]:    all records when processing early data records.
    TEXT[!MUST]: Specifically, if the
    TEXT[!MUST]:    server fails to decrypt a 0-RTT record following an accepted
    TEXT[!MUST]:    "early_data" extension, it MUST terminate the connection with a
    TEXT[!MUST]:    "bad_record_mac" alert as per Section 5.2.
    TEXT[!MAY]:    If the server rejects the "early_data" extension, the client
    TEXT[!MAY]:    application MAY opt to retransmit the Application Data previously
    TEXT[!MAY]:    sent in early data once the handshake has been completed.
    TEXT[!SHOULD]:    A TLS implementation SHOULD NOT automatically resend early data;
    TEXT[!SHOULD]:    applications are in a better position to decide when retransmission
    TEXT[!SHOULD]:    is appropriate.
    TEXT[!MUST]: A TLS implementation MUST NOT automatically resend
    TEXT[!MUST]:    early data unless the negotiated connection selects the same ALPN
    TEXT[!MUST]:    protocol.

  SECTION: [Pre-Shared Key Extension](#section-4.2.11)
    TEXT[!MUST]: For identities
    TEXT[!MUST]:       established externally, an obfuscated_ticket_age of 0 SHOULD be
    TEXT[!MUST]:       used, and servers MUST ignore the value.
    TEXT[!MUST]:    For externally established PSKs, the Hash algorithm MUST be set when
    TEXT[!MUST]: The server MUST ensure that it selects a compatible PSK
    TEXT[!MUST]:    (if any) and cipher suite.
    TEXT[!SHOULD]: Clients, however, SHOULD
    TEXT[!SHOULD]:    store the SNI with the PSK to fulfill the requirements of
    TEXT[!SHOULD]:    Section 4.6.1.
    TEXT[!SHOULD]: Any unknown PSKs (e.g., ones
    TEXT[!SHOULD]:    not in the PSK database or encrypted with an unknown key) SHOULD
    TEXT[!SHOULD]:    simply be ignored.
    TEXT[!SHOULD]: If no acceptable PSKs are found, the server
    TEXT[!SHOULD]:    SHOULD perform a non-PSK handshake if possible.
    TEXT[!SHOULD]: If backward
    TEXT[!SHOULD]:    compatibility is important, client-provided, externally established
    TEXT[!SHOULD]:    PSKs SHOULD influence cipher suite selection.
    TEXT[!MUST]:    Prior to accepting PSK key establishment, the server MUST validate
    TEXT[!MUST]:    the corresponding binder value (see Section 4.2.11.2 below).
    TEXT[!MUST]: If this
    TEXT[!MUST]:    value is not present or does not validate, the server MUST abort the
    TEXT[!MUST]:    handshake.
    TEXT[!SHOULD]: Servers SHOULD NOT attempt to validate multiple binders;
    TEXT[!SHOULD]:    rather, they SHOULD select a single PSK and validate solely the
    TEXT[!SHOULD]:    binder that corresponds to that PSK.
    TEXT[!MUST]:    Clients MUST verify that the server's selected_identity is within the
    TEXT[!MUST]:    range supplied by the client, that the server selected a cipher suite
    TEXT[!MUST]:    indicating a Hash associated with the PSK, and that a server
    TEXT[!MUST]:    "key_share" extension is present if required by the ClientHello
    TEXT[!MUST]:    "psk_key_exchange_modes" extension.
    TEXT[!MUST]: If these values are not
    TEXT[!MUST]:    consistent, the client MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert.
    TEXT[!MUST]:    If the server supplies an "early_data" extension, the client MUST
    TEXT[!MUST]:    verify that the server's selected_identity is 0.
    TEXT[!MUST]: If any other value
    TEXT[!MUST]:    is returned, the client MUST abort the handshake with an
    TEXT[!MUST]:    "illegal_parameter" alert.
    TEXT[!MUST]:    The "pre_shared_key" extension MUST be the last extension in the
    TEXT[!MUST]:    ClientHello (this facilitates implementation as described below).
    TEXT[!MUST]:    Servers MUST check that it is the last extension and otherwise fail
    TEXT[!MUST]:    the handshake with an "illegal_parameter" alert.

  SECTION: [Ticket Age](#section-4.2.11.1)
    TEXT[!MUST]: Clients MUST NOT attempt to
    TEXT[!MUST]:    use tickets which have ages greater than the "ticket_lifetime" value
    TEXT[!MUST]:    which was provided with the ticket.

  SECTION: [Processing Order](#section-4.2.11.3)
    TEXT[!MUST]: In order to avoid deadlocks,
    TEXT[!MUST]:    when accepting "early_data", servers MUST process the client's
    TEXT[!MUST]:    ClientHello and then immediately send their flight of messages,
    TEXT[!MUST]:    rather than waiting for the client's EndOfEarlyData message before
    TEXT[!MUST]:    sending its ServerHello.

  SECTION: [Encrypted Extensions](#section-4.3.1)
    TEXT[!MUST]:    In all handshakes, the server MUST send the EncryptedExtensions
    TEXT[!MUST]:    message immediately after the ServerHello message.
    TEXT[!MUST]: The client MUST check EncryptedExtensions for the
    TEXT[!MUST]:    presence of any forbidden extensions and if any are found MUST abort
    TEXT[!MUST]:    the handshake with an "illegal_parameter" alert.

  SECTION: [Certificate Request](#section-4.3.2)
    TEXT[!MAY]:    A server which is authenticating with a certificate MAY optionally
    TEXT[!MAY]:    request a certificate from the client.
    TEXT[!MUST]: This message, if sent, MUST
    TEXT[!MUST]:    follow EncryptedExtensions.
    TEXT[!MUST]: The certificate_request_context MUST be
    TEXT[!MUST]:       unique within the scope of this connection (thus preventing replay
    TEXT[!MUST]:       of client CertificateVerify messages).
    TEXT[!MUST]: This field SHALL be zero
    TEXT[!MUST]:       length unless used for the post-handshake authentication exchanges
    TEXT[!MUST]:       described in Section 4.6.2.
    TEXT[!SHOULD]: When requesting post-handshake
    TEXT[!SHOULD]:       authentication, the server SHOULD make the context unpredictable
    TEXT[!SHOULD]:       to the client (e.g., by randomly generating it) in order to
    TEXT[!SHOULD]:       prevent an attacker who has temporary access to the client's
    TEXT[!SHOULD]:       private key from pre-computing valid CertificateVerify messages.
    TEXT[!MUST]: The "signature_algorithms" extension
    TEXT[!MUST]:       MUST be specified, and other extensions may optionally be included
    TEXT[!MUST]:       if defined for this message.
    TEXT[!MUST]: Clients MUST ignore unrecognized
    TEXT[!MUST]:       extensions.
    TEXT[!MUST]:    Servers which are authenticating with a PSK MUST NOT send the
    TEXT[!MUST]:    CertificateRequest message in the main handshake, though they MAY
    TEXT[!MUST]:    send it in post-handshake authentication (see Section 4.6.2) provided
    TEXT[!MUST]:    that the client has sent the "post_handshake_auth" extension (see
    TEXT[!MUST]:    Section 4.2.6).

  SECTION: [Certificate](#section-4.4.2)
    TEXT[!MUST]:    The server MUST send a Certificate message whenever the agreed-upon
    TEXT[!MUST]:    key exchange method uses certificates for authentication (this
    TEXT[!MUST]:    includes all key exchange methods defined in this document
    TEXT[!MUST]:    except PSK).
    TEXT[!MUST]:    The client MUST send a Certificate message if and only if the server
    TEXT[!MUST]:    has requested client authentication via a CertificateRequest message
    TEXT[!MUST]:    (Section 4.3.2).
    TEXT[!MUST]: If the server requests client authentication but no
    TEXT[!MUST]:    suitable certificate is available, the client MUST send a Certificate
    TEXT[!MUST]:    message containing no certificates (i.e., with the "certificate_list"
    TEXT[!MUST]:    field having length 0).
    TEXT[!MUST]: A Finished message MUST be sent regardless
    TEXT[!MUST]:    of whether the Certificate message is empty.
    TEXT[!MUST]: Otherwise (in the case of server authentication),
    TEXT[!MUST]:       this field SHALL be zero length.
    TEXT[!MUST]: Extensions in the Certificate message from the server MUST
    TEXT[!MUST]:       correspond to ones from the ClientHello message.
    TEXT[!MUST]: Extensions in
    TEXT[!MUST]:       the Certificate message from the client MUST correspond to
    TEXT[!MUST]:       extensions in the CertificateRequest message from the server.
    TEXT[!SHOULD]: If
    TEXT[!SHOULD]:       an extension applies to the entire chain, it SHOULD be included in
    TEXT[!SHOULD]:       the first CertificateEntry.
    TEXT[!MUST]: The sender's certificate MUST come in the first
    TEXT[!MUST]:    CertificateEntry in the list.
    TEXT[!SHOULD]: Each following certificate SHOULD
    TEXT[!SHOULD]:    directly certify the one immediately preceding it.
    TEXT[!MAY]: Because
    TEXT[!MAY]:    certificate validation requires that trust anchors be distributed
    TEXT[!MAY]:    independently, a certificate that specifies a trust anchor MAY be
    TEXT[!MAY]:    omitted from the chain, provided that supported peers are known to
    TEXT[!MAY]:    possess any omitted certificates.
    TEXT[!MUST]: For maximum
    TEXT[!MUST]:    compatibility, all implementations SHOULD be prepared to handle
    TEXT[!MUST]:    potentially extraneous certificates and arbitrary orderings from any
    TEXT[!MUST]:    TLS version, with the exception of the end-entity certificate which
    TEXT[!MUST]:    MUST be first.
    TEXT[!MUST]:    If the RawPublicKey certificate type was negotiated, then the
    TEXT[!MUST]:    certificate_list MUST contain no more than one CertificateEntry,
    TEXT[!MUST]:    which contains an ASN1_subjectPublicKeyInfo value as defined in
    TEXT[!MUST]:    [RFC7250], Section 3.
    TEXT[!MUST]:    The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.
    TEXT[!MUST]:    The server's certificate_list MUST always be non-empty.

  SECTION: [OCSP Status and SCT Extensions](#section-4.4.2.1)
    TEXT[!MUST]: Specifically, the body of the
    TEXT[!MUST]:    "status_request" extension from the server MUST be a
    TEXT[!MUST]:    CertificateStatus structure as defined in [RFC6066], which is
    TEXT[!MUST]:    interpreted as defined in [RFC6960].
    TEXT[!MUST]:    TLS 1.3 servers MUST NOT act upon its presence or information in it
    TEXT[!MUST]:    when processing ClientHello messages; in particular, they MUST NOT
    TEXT[!MUST]:    send the status_request_v2 extension in the EncryptedExtensions,
    TEXT[!MUST]:    CertificateRequest, or Certificate messages.
    TEXT[!MUST]: TLS 1.3 servers MUST be
    TEXT[!MUST]:    able to process ClientHello messages that include it, as it MAY be
    TEXT[!MUST]:    sent by clients that wish to use it in earlier protocol versions.
    TEXT[!MAY]:    A server MAY request that a client present an OCSP response with its
    TEXT[!MAY]:    certificate by sending an empty "status_request" extension in its
    TEXT[!MAY]:    CertificateRequest message.
    TEXT[!MUST]: If the client opts to send an OCSP
    TEXT[!MUST]:    response, the body of its "status_request" extension MUST be a
    TEXT[!MUST]:    CertificateStatus structure as defined in [RFC6066].

  SECTION: [Server Certificate Selection](#section-4.4.2.2)
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly
    TEXT[!MUST]:       negotiated otherwise (e.g., [RFC7250]).
    TEXT[!MUST]:    -  The server's end-entity certificate's public key (and associated
    TEXT[!MUST]:       restrictions) MUST be compatible with the selected authentication
    TEXT[!MUST]:       algorithm from the client's "signature_algorithms" extension
    TEXT[!MUST]:       (currently RSA, ECDSA, or EdDSA).
    TEXT[!MUST]:    -  The certificate MUST allow the key to be used for signing (i.e.,
    TEXT[!MUST]:       the digitalSignature bit MUST be set if the Key Usage extension is
    TEXT[!MUST]:       present) with a signature scheme indicated in the client's
    TEXT[!MUST]:       "signature_algorithms"/"signature_algorithms_cert" extensions (see
    TEXT[!MUST]:       Section 4.2.3).
    TEXT[!SHOULD]: As servers
    TEXT[!SHOULD]:       MAY require the presence of the "server_name" extension, clients
    TEXT[!SHOULD]:       SHOULD send this extension, when applicable.
    TEXT[!MUST]:    All certificates provided by the server MUST be signed by a signature
    TEXT[!MUST]:    algorithm advertised by the client if it is able to provide such a
    TEXT[!MUST]:    chain (see Section 4.2.3).
    TEXT[!MAY]: Certificates that are self-signed or
    TEXT[!MAY]:    certificates that are expected to be trust anchors are not validated
    TEXT[!MAY]:    as part of the chain and therefore MAY be signed with any algorithm.
    TEXT[!SHOULD]:    If the server cannot produce a certificate chain that is signed only
    TEXT[!SHOULD]:    via the indicated supported algorithms, then it SHOULD continue the
    TEXT[!SHOULD]:    handshake by sending the client a certificate chain of its choice
    TEXT[!SHOULD]:    that may include algorithms that are not known to be supported by the
    TEXT[!SHOULD]:    client.
    TEXT[!MUST]: This fallback chain SHOULD NOT use the deprecated SHA-1 hash
    TEXT[!MUST]:    algorithm in general, but MAY do so if the client's advertisement
    TEXT[!MUST]:    permits it, and MUST NOT do so otherwise.
    TEXT[!MUST]:    If the client cannot construct an acceptable chain using the provided
    TEXT[!MUST]:    certificates and decides to abort the handshake, then it MUST abort
    TEXT[!MUST]:    the handshake with an appropriate certificate-related alert (by
    TEXT[!MUST]:    default, "unsupported_certificate"; see Section 6.2 for more
    TEXT[!MUST]:    information).

  SECTION: [Client Certificate Selection](#section-4.4.2.3)
    TEXT[!MUST]:    -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly
    TEXT[!MUST]:       negotiated otherwise (e.g., [RFC7250]).
    TEXT[!SHOULD]:    -  If the "certificate_authorities" extension in the
    TEXT[!SHOULD]:       CertificateRequest message was present, at least one of the
    TEXT[!SHOULD]:       certificates in the certificate chain SHOULD be issued by one of
    TEXT[!SHOULD]:       the listed CAs.
    TEXT[!MUST]:    -  The certificates MUST be signed using an acceptable signature
    TEXT[!MUST]:       algorithm, as described in Section 4.3.2.
    TEXT[!MUST]:    -  If the CertificateRequest message contained a non-empty
    TEXT[!MUST]:       "oid_filters" extension, the end-entity certificate MUST match the
    TEXT[!MUST]:       extension OIDs that are recognized by the client, as described in
    TEXT[!MUST]:       Section 4.2.5.

  SECTION: [Receiving a Certificate Message](#section-4.4.2.4)
    TEXT[!MUST]:    If the server supplies an empty Certificate message, the client MUST
    TEXT[!MUST]:    abort the handshake with a "decode_error" alert.
    TEXT[!MAY]:    If the client does not send any certificates (i.e., it sends an empty
    TEXT[!MAY]:    Certificate message), the server MAY at its discretion either
    TEXT[!MAY]:    continue the handshake without client authentication or abort the
    TEXT[!MAY]:    handshake with a "certificate_required" alert.
    TEXT[!MAY]: Also, if some aspect
    TEXT[!MAY]:    of the certificate chain was unacceptable (e.g., it was not signed by
    TEXT[!MAY]:    a known, trusted CA), the server MAY at its discretion either
    TEXT[!MAY]:    continue the handshake (considering the client unauthenticated) or
    TEXT[!MAY]:    abort the handshake.
    TEXT[!MUST]:    Any endpoint receiving any certificate which it would need to
    TEXT[!MUST]:    validate using any signature algorithm using an MD5 hash MUST abort
    TEXT[!MUST]:    the handshake with a "bad_certificate" alert.
    TEXT[!SHOULD]: SHA-1 is deprecated,
    TEXT[!SHOULD]:    and it is RECOMMENDED that any endpoint receiving any certificate
    TEXT[!SHOULD]:    which it would need to validate using any signature algorithm using a
    TEXT[!SHOULD]:    SHA-1 hash abort the handshake with a "bad_certificate" alert.
    TEXT[!SHOULD]:    All endpoints are RECOMMENDED to transition to SHA-256 or better as
    TEXT[!SHOULD]:    soon as possible to maintain interoperability with implementations
    TEXT[!SHOULD]:    currently in the process of phasing out SHA-1 support.
    TEXT[!MAY]:    Note that a certificate containing a key for one signature algorithm
    TEXT[!MAY]:    MAY be signed using a different signature algorithm (for instance, an
    TEXT[!MAY]:    RSA key signed with an ECDSA key).

  SECTION: [Certificate Verify](#section-4.4.3)
    TEXT[!MUST]: Servers MUST send this message when authenticating
    TEXT[!MUST]:    via a certificate.
    TEXT[!MUST]: Clients MUST send this message whenever
    TEXT[!MUST]:    authenticating via a certificate (i.e., when the Certificate message
    TEXT[!MUST]:    is non-empty).
    TEXT[!MUST]: When sent, this message MUST appear immediately after
    TEXT[!MUST]:    the Certificate message and immediately prior to the Finished
    TEXT[!MUST]:    message.
    TEXT[!MUST]:    If the CertificateVerify message is sent by a server, the signature
    TEXT[!MUST]:    algorithm MUST be one offered in the client's "signature_algorithms"
    TEXT[!MUST]:    extension unless no valid certificate chain can be produced without
    TEXT[!MUST]:    unsupported algorithms (see Section 4.2.3).
    TEXT[!MUST]:    If sent by a client, the signature algorithm used in the signature
    TEXT[!MUST]:    MUST be one of those present in the supported_signature_algorithms
    TEXT[!MUST]:    field of the "signature_algorithms" extension in the
    TEXT[!MUST]:    CertificateRequest message.
    TEXT[!MUST]:    In addition, the signature algorithm MUST be compatible with the key
    TEXT[!MUST]:    in the sender's end-entity certificate.
    TEXT[!MUST]: RSA signatures MUST use an
    TEXT[!MUST]:    RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5
    TEXT[!MUST]:    algorithms appear in "signature_algorithms".
    TEXT[!MUST]: The SHA-1 algorithm
    TEXT[!MUST]:    MUST NOT be used in any signatures of CertificateVerify messages.
    TEXT[!MUST]:    The receiver of a CertificateVerify message MUST verify the signature
    TEXT[!MUST]:    field.
    TEXT[!MUST]:    If the verification fails, the receiver MUST terminate the handshake
    TEXT[!MUST]:    with a "decrypt_error" alert.

  SECTION: [Finished](#section-4.4.4)
    TEXT[!MUST]:    Recipients of Finished messages MUST verify that the contents are
    TEXT[!MUST]:    correct and if incorrect MUST terminate the connection with a
    TEXT[!MUST]:    "decrypt_error" alert.
    TEXT[!MAY]: Servers MAY send data after sending their first flight, but
    TEXT[!MAY]:        because the handshake is not yet complete, they have no assurance
    TEXT[!MAY]:        of either the peer's identity or its liveness (i.e., the
    TEXT[!MAY]:        ClientHello might have been replayed).
    TEXT[!MUST]:    Any records following a Finished message MUST be encrypted under the
    TEXT[!MUST]:    appropriate application traffic key as described in Section 7.2.

  SECTION: [End of Early Data](#section-4.5)
    TEXT[!MUST]:    If the server sent an "early_data" extension in EncryptedExtensions,
    TEXT[!MUST]:    the client MUST send an EndOfEarlyData message after receiving the
    TEXT[!MUST]:    server Finished.
    TEXT[!MUST]: If the server does not send an "early_data"
    TEXT[!MUST]:    extension in EncryptedExtensions, then the client MUST NOT send an
    TEXT[!MUST]:    EndOfEarlyData message.
    TEXT[!MUST]:    Servers MUST NOT send this message, and clients receiving it MUST
    TEXT[!MUST]:    terminate the connection with an "unexpected_message" alert.

  SECTION: [New Session Ticket Message](#section-4.6.1)
    TEXT[!MAY]:    At any time after the server has received the client Finished
    TEXT[!MAY]:    message, it MAY send a NewSessionTicket message.
    TEXT[!MAY]:    The client MAY use this PSK for future handshakes by including the
    TEXT[!MAY]:    ticket value in the "pre_shared_key" extension in its ClientHello
    TEXT[!MAY]:    (Section 4.2.11).
    TEXT[!MAY]: Servers MAY send multiple tickets on a single
    TEXT[!MAY]:    connection, either immediately after each other or after specific
    TEXT[!MAY]:    events (see Appendix C.4).
    TEXT[!MUST]:    Any ticket MUST only be resumed with a cipher suite that has the same
    TEXT[!MUST]:    KDF hash algorithm as that used to establish the original connection.
    TEXT[!MUST]:    Clients MUST only resume if the new SNI value is valid for the server
    TEXT[!MUST]:    certificate presented in the original session and SHOULD only resume
    TEXT[!MUST]:    if the SNI value matches the one used in the original session.
    TEXT[!MAY]: If such an indication
    TEXT[!MAY]:    is provided (externally or by any other means), clients MAY resume
    TEXT[!MAY]:    with a different SNI value.
    TEXT[!MUST]:    On resumption, if reporting an SNI value to the calling application,
    TEXT[!MUST]:    implementations MUST use the value sent in the resumption ClientHello
    TEXT[!MUST]:    rather than the value sent in the previous session.
    TEXT[!MAY]:    Note: Although the resumption master secret depends on the client's
    TEXT[!MAY]:    second flight, a server which does not request client authentication
    TEXT[!MAY]:    MAY compute the remainder of the transcript independently and then
    TEXT[!MAY]:    send a NewSessionTicket immediately upon sending its Finished rather
    TEXT[!MAY]:    than waiting for the client Finished.
    TEXT[!MUST]: Servers MUST NOT use any value greater than
    TEXT[!MUST]:       604800 seconds (7 days).
    TEXT[!MUST]: Clients MUST NOT cache
    TEXT[!MUST]:       tickets for longer than 7 days, regardless of the ticket_lifetime,
    TEXT[!MUST]:       and MAY delete tickets earlier based on local policy.
    TEXT[!MAY]: A server
    TEXT[!MAY]:       MAY treat a ticket as valid for a shorter period of time than what
    TEXT[!MAY]:       is stated in the ticket_lifetime.
    TEXT[!MUST]: The server MUST generate a fresh value
    TEXT[!MUST]:       for each ticket it sends.
    TEXT[!MAY]: It MAY be either a database
    TEXT[!MAY]:       lookup key or a self-encrypted and self-authenticated value.
    TEXT[!MUST]: Clients MUST ignore
    TEXT[!MUST]:       unrecognized extensions.
    TEXT[!SHOULD]: A server receiving more than
    TEXT[!SHOULD]:       max_early_data_size bytes of 0-RTT data SHOULD terminate the
    TEXT[!SHOULD]:       connection with an "unexpected_message" alert.
    TEXT[!SHOULD]: Note that servers
    TEXT[!SHOULD]:       that reject early data due to lack of cryptographic material will
    TEXT[!SHOULD]:       be unable to differentiate padding from content, so clients
    TEXT[!SHOULD]:       SHOULD NOT depend on being able to send large quantities of
    TEXT[!SHOULD]:       padding in early data records.
    TEXT[!SHOULD]: It is RECOMMENDED that
    TEXT[!SHOULD]:    implementations place limits on the total lifetime of such keying
    TEXT[!SHOULD]:    material; these limits should take into account the lifetime of the
    TEXT[!SHOULD]:    peer's certificate, the likelihood of intervening revocation, and the
    TEXT[!SHOULD]:    time since the peer's online CertificateVerify signature.

  SECTION: [Post-Handshake Authentication](#section-4.6.2)
    TEXT[!MAY]:    When the client has sent the "post_handshake_auth" extension (see
    TEXT[!MAY]:    Section 4.2.6), a server MAY request client authentication at any
    TEXT[!MAY]:    time after the handshake has completed by sending a
    TEXT[!MAY]:    CertificateRequest message.
    TEXT[!MUST]: The client MUST respond with the
    TEXT[!MUST]:    appropriate Authentication messages (see Section 4.4).
    TEXT[!MUST]: If the client
    TEXT[!MUST]:    chooses to authenticate, it MUST send Certificate, CertificateVerify,
    TEXT[!MUST]: If it declines, it MUST send a Certificate message
    TEXT[!MUST]:    containing no certificates followed by Finished.
    TEXT[!MUST]: All of the client's
    TEXT[!MUST]:    messages for a given response MUST appear consecutively on the wire
    TEXT[!MUST]:    with no intervening messages of other types.
    TEXT[!MUST]:    A client that receives a CertificateRequest message without having
    TEXT[!MUST]:    sent the "post_handshake_auth" extension MUST send an
    TEXT[!MUST]:    "unexpected_message" fatal alert.
    TEXT[!MUST]:    Note: Because client authentication could involve prompting the user,
    TEXT[!MUST]:    servers MUST be prepared for some delay, including receiving an
    TEXT[!MUST]:    arbitrary number of other messages between sending the
    TEXT[!MUST]:    CertificateRequest and receiving a response.
    TEXT[!MAY]: In addition, clients
    TEXT[!MAY]:    which receive multiple CertificateRequests in close succession MAY
    TEXT[!MAY]:    respond to them in a different order than they were received (the
    TEXT[!MAY]:    certificate_request_context value allows the server to disambiguate
    TEXT[!MAY]:    the responses).

  SECTION: [Key and Initialization Vector Update](#section-4.6.3)
    TEXT[!MUST]: Implementations
    TEXT[!MUST]:    that receive a KeyUpdate message prior to receiving a Finished
    TEXT[!MUST]:    message MUST terminate the connection with an "unexpected_message"
    TEXT[!MUST]:    alert.
    TEXT[!MUST]: After sending a KeyUpdate message, the sender SHALL send all
    TEXT[!MUST]:    its traffic using the next generation of keys, computed as described
    TEXT[!MUST]:    in Section 7.2.
    TEXT[!MUST]: Upon receiving a KeyUpdate, the receiver MUST update
    TEXT[!MUST]:    its receiving keys.
    TEXT[!MUST]: If an implementation
    TEXT[!MUST]:       receives any other value, it MUST terminate the connection with an
    TEXT[!MUST]:       "illegal_parameter" alert.
    TEXT[!MUST]:    If the request_update field is set to "update_requested", then the
    TEXT[!MUST]:    receiver MUST send a KeyUpdate of its own with request_update set to
    TEXT[!MUST]:    "update_not_requested" prior to sending its next Application Data
    TEXT[!MUST]:    record.
    TEXT[!MUST]:    Both sender and receiver MUST encrypt their KeyUpdate messages with
    TEXT[!MUST]:    the old keys.
    TEXT[!MUST]: Additionally, both sides MUST enforce that a KeyUpdate
    TEXT[!MUST]:    with the old key is received before accepting any messages encrypted
    TEXT[!MUST]:    with the new key.

  SECTION: [Record Protocol](#section-5)
    TEXT[!MUST]:    An implementation may receive an unencrypted record of type
    TEXT[!MUST]:    change_cipher_spec consisting of the single byte value 0x01 at any
    TEXT[!MUST]:    time after the first ClientHello message has been sent or received
    TEXT[!MUST]:    and before the peer's Finished message has been received and MUST
    TEXT[!MUST]:    simply drop it without further processing.
    TEXT[!MUST]: An
    TEXT[!MUST]:    implementation which receives any other change_cipher_spec value or
    TEXT[!MUST]:    which receives a protected change_cipher_spec record MUST abort the
    TEXT[!MUST]:    handshake with an "unexpected_message" alert.
    TEXT[!MUST]: If an implementation
    TEXT[!MUST]:    detects a change_cipher_spec record received before the first
    TEXT[!MUST]:    ClientHello message or after the peer's Finished message, it MUST be
    TEXT[!MUST]:    treated as an unexpected record type (though stateless servers may
    TEXT[!MUST]:    not be able to distinguish these cases from allowed cases).
    TEXT[!MUST]:    Implementations MUST NOT send record types not defined in this
    TEXT[!MUST]:    document unless negotiated by some extension.
    TEXT[!MUST]: If a TLS
    TEXT[!MUST]:    implementation receives an unexpected record type, it MUST terminate
    TEXT[!MUST]:    the connection with an "unexpected_message" alert.

  SECTION: [Record Layer](#section-5.1)
    TEXT[!MUST]: Any future content types MUST specify appropriate
    TEXT[!MUST]:    rules.
    TEXT[!MAY]:    Handshake messages MAY be coalesced into a single TLSPlaintext record
    TEXT[!MAY]:    or fragmented across several records, provided that:
    TEXT[!MUST]:    -  Handshake messages MUST NOT be interleaved with other record
    TEXT[!MUST]:       types.
    TEXT[!MUST]: That is, if a handshake message is split over two or more
    TEXT[!MUST]:       records, there MUST NOT be any other records between them.
    TEXT[!MUST]:    -  Handshake messages MUST NOT span key changes.
    TEXT[!MUST]: Implementations
    TEXT[!MUST]:       MUST verify that all messages immediately preceding a key change
    TEXT[!MUST]:       align with a record boundary; if not, then they MUST terminate the
    TEXT[!MUST]:       connection with an "unexpected_message" alert.
    TEXT[!MUST]: Because the
    TEXT[!MUST]:       ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate
    TEXT[!MUST]:       messages can immediately precede a key change, implementations
    TEXT[!MUST]:       MUST send these messages in alignment with a record boundary.
    TEXT[!MUST]:    Implementations MUST NOT send zero-length fragments of Handshake
    TEXT[!MUST]:    types, even if those fragments contain padding.
    TEXT[!MUST]:    Alert messages (Section 6) MUST NOT be fragmented across records, and
    TEXT[!MUST]:    multiple alert messages MUST NOT be coalesced into a single
    TEXT[!MUST]:    TLSPlaintext record.
    TEXT[!MUST]: In other words, a record with an Alert type
    TEXT[!MUST]:    MUST contain exactly one message.
    TEXT[!MAY]: Zero-length
    TEXT[!MAY]:    fragments of Application Data MAY be sent, as they are potentially
    TEXT[!MAY]:    useful as a traffic analysis countermeasure.
    TEXT[!MAY]: Application Data
    TEXT[!MAY]:    fragments MAY be split across multiple records or coalesced into a
    TEXT[!MAY]:    single record.
    TEXT[!MUST]:    legacy_record_version:  MUST be set to 0x0303 for all records
    TEXT[!MUST]:       generated by a TLS 1.3 implementation other than an initial
    TEXT[!MUST]:       ClientHello (i.e., one not generated after a HelloRetryRequest),
    TEXT[!MUST]:       where it MAY also be 0x0301 for compatibility purposes.
    TEXT[!MUST]: This
    TEXT[!MUST]:       field is deprecated and MUST be ignored for all purposes.
    TEXT[!MUST]: The length MUST NOT exceed 2^14 bytes.
    TEXT[!MUST]: An
    TEXT[!MUST]:       endpoint that receives a record that exceeds this length MUST
    TEXT[!MUST]:       terminate the connection with a "record_overflow" alert.
    TEXT[!MUST]: In order to maximize backward
    TEXT[!MUST]:    compatibility, a record containing an initial ClientHello SHOULD have
    TEXT[!MUST]:    version 0x0301 (reflecting TLS 1.0) and a record containing a second
    TEXT[!MUST]:    ClientHello or a ServerHello MUST have version 0x0303 (reflecting
    TEXT[!MUST]:    TLS 1.2).
    TEXT[!MUST]: Note that Application Data
    TEXT[!MUST]:    records MUST NOT be written to the wire unprotected (see Section 2
    TEXT[!MUST]:    for details).

  SECTION: [Record Payload Protection](#section-5.2)
    TEXT[!MUST]: The length
    TEXT[!MUST]:       MUST NOT exceed 2^14 + 256 bytes.
    TEXT[!MUST]: An endpoint that receives a
    TEXT[!MUST]:       record that exceeds this length MUST terminate the connection with
    TEXT[!MUST]:       a "record_overflow" alert.
    TEXT[!MUST]:    If the decryption fails, the receiver MUST terminate the connection
    TEXT[!MUST]:    with a "bad_record_mac" alert.
    TEXT[!MUST]:    An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion
    TEXT[!MUST]:    greater than 255 octets.
    TEXT[!MUST]: An endpoint that receives a record from its
    TEXT[!MUST]:    peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST
    TEXT[!MUST]:    terminate the connection with a "record_overflow" alert.

  SECTION: [Per-Record Nonce](#section-5.3)
    TEXT[!MUST]: Each sequence number is
    TEXT[!MUST]:    set to zero at the beginning of a connection and whenever the key is
    TEXT[!MUST]:    changed; the first record transmitted under a particular traffic key
    TEXT[!MUST]:    MUST use sequence number 0.
    TEXT[!MUST]:    If a TLS implementation would need to wrap a sequence number, it MUST
    TEXT[!MUST]:    either rekey (Section 4.6.3) or terminate the connection.
    TEXT[!MUST]: An AEAD algorithm where N_MAX is less than 8 bytes
    TEXT[!MUST]:    MUST NOT be used with TLS.

  SECTION: [Record Padding](#section-5.4)
    TEXT[!MAY]:    When generating a TLSCiphertext record, implementations MAY choose to
    TEXT[!MAY]:    pad.
    TEXT[!MUST]: Implementations MUST set the
    TEXT[!MUST]:    padding octets to all zeros before encrypting.
    TEXT[!MUST]: Implementations
    TEXT[!MUST]:    MUST NOT send Handshake and Alert records that have a zero-length
    TEXT[!MUST]:    TLSInnerPlaintext.content; if such a message is received, the
    TEXT[!MUST]:    receiving implementation MUST terminate the connection with an
    TEXT[!MUST]:    "unexpected_message" alert.
    TEXT[!MUST]:    Implementations MUST limit their scanning to the cleartext returned
    TEXT[!MUST]:    from the AEAD decryption.
    TEXT[!MUST]: If a receiving implementation does not
    TEXT[!MUST]:    find a non-zero octet in the cleartext, it MUST terminate the
    TEXT[!MUST]:    connection with an "unexpected_message" alert.
    TEXT[!MUST]:    The presence of padding does not change the overall record size
    TEXT[!MUST]:    limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14
    TEXT[!MUST]:    + 1 octets.

  SECTION: [Limits on Key Usage](#section-5.5)
    TEXT[!SHOULD]:    Implementations SHOULD do a key update as described in Section 4.6.3
    TEXT[!SHOULD]:    prior to reaching these limits.

  SECTION: [Alert Protocol](#section-6)
    TEXT[!SHOULD]: Upon receiving such an alert, the TLS
    TEXT[!SHOULD]:    implementation SHOULD indicate end-of-data to the application.
    TEXT[!MUST]: Upon receiving an error alert, the TLS implementation
    TEXT[!MUST]:    SHOULD indicate an error to the application and MUST NOT allow any
    TEXT[!MUST]:    further data to be sent or received on the connection.
    TEXT[!MUST]: Servers and
    TEXT[!MUST]:    clients MUST forget the secret values and keys established in failed
    TEXT[!MUST]:    connections, with the exception of the PSKs associated with session
    TEXT[!MUST]:    tickets, which SHOULD be discarded if possible.
    TEXT[!MUST]:    All the alerts listed in Section 6.2 MUST be sent with
    TEXT[!MUST]:    AlertLevel=fatal and MUST be treated as error alerts when received
    TEXT[!MUST]:    regardless of the AlertLevel in the message.
    TEXT[!MUST]: Unknown Alert types
    TEXT[!MUST]:    MUST be treated as error alerts.
    TEXT[!MUST]: Peers which receive a message which
    TEXT[!MUST]:    cannot be parsed according to the syntax (e.g., have a length
    TEXT[!MUST]:    extending beyond the message boundary or contain an out-of-range
    TEXT[!MUST]:    length) MUST terminate the connection with a "decode_error" alert.
    TEXT[!MUST]:    Peers which receive a message which is syntactically correct but
    TEXT[!MUST]:    semantically invalid (e.g., a DHE share of p - 1, or an invalid enum)
    TEXT[!MUST]:    MUST terminate the connection with an "illegal_parameter" alert.

  SECTION: [Closure Alerts](#section-6.1)
    TEXT[!MUST]: Any data received
    TEXT[!MUST]:       after a closure alert has been received MUST be ignored.
    TEXT[!SHOULD]: This alert SHOULD be followed by a
    TEXT[!SHOULD]:       "close_notify".
    TEXT[!MAY]:    Either party MAY initiate a close of its write side of the connection
    TEXT[!MAY]:    by sending a "close_notify" alert.
    TEXT[!MUST]:    Each party MUST send a "close_notify" alert before closing its write
    TEXT[!MUST]:    side of the connection, unless it has already sent some error alert.
    TEXT[!MUST]:    If the application protocol using TLS provides that any data may be
    TEXT[!MUST]:    carried over the underlying transport after the TLS connection is
    TEXT[!MUST]:    closed, the TLS implementation MUST receive a "close_notify" alert
    TEXT[!MUST]:    before indicating end-of-data to the application layer.

  SECTION: [Error Alerts](#section-6.2)
    TEXT[!MUST]: Upon transmission or
    TEXT[!MUST]:    receipt of a fatal alert message, both parties MUST immediately close
    TEXT[!MUST]:    the connection.
    TEXT[!MUST]:    Whenever an implementation encounters a fatal error condition, it
    TEXT[!MUST]:    SHOULD send an appropriate fatal alert and MUST close the connection
    TEXT[!MUST]:    without sending or receiving any additional data.
    TEXT[!SHOULD]: In the rest of
    TEXT[!SHOULD]:    this specification, when the phrases "terminate the connection" and
    TEXT[!SHOULD]:    "abort the handshake" are used without a specific alert it means that
    TEXT[!SHOULD]:    the implementation SHOULD send the alert indicated by the
    TEXT[!SHOULD]:    descriptions below.
    TEXT[!MUST]: The phrases "terminate the connection with an X
    TEXT[!MUST]:    alert" and "abort the handshake with an X alert" mean that the
    TEXT[!MUST]:    implementation MUST send alert X if it sends any alert.
    TEXT[!SHOULD]: The
    TEXT[!SHOULD]:    implementation SHOULD provide a way to facilitate logging the sending
    TEXT[!SHOULD]:    and receiving of alerts.
    TEXT[!MAY]:       Sending this alert is OPTIONAL; servers MAY instead choose to send
    TEXT[!MAY]:       a "decrypt_error" alert to merely indicate an invalid PSK
    TEXT[!MAY]:       identity.

  SECTION: [Key Schedule](#section-7.1)
    TEXT[!SHOULD]:    Once all the values which are to be derived from a given secret have
    TEXT[!SHOULD]:    been computed, that secret SHOULD be erased.

  SECTION: [Updating Traffic Secrets](#section-7.2)
    TEXT[!SHOULD]:    Once client_/server_application_traffic_secret_N+1 and its associated
    TEXT[!SHOULD]:    traffic keys have been computed, implementations SHOULD delete
    TEXT[!SHOULD]:    client_/server_application_traffic_secret_N and its associated
    TEXT[!SHOULD]:    traffic keys.

  SECTION: [Elliptic Curve Diffie-Hellman](#section-7.4.2)
    TEXT[!MUST]:    Note that this octet string ("Z" in IEEE 1363 terminology) as output
    TEXT[!MUST]:    by FE2OSP (the Field Element to Octet String Conversion Primitive)
    TEXT[!MUST]:    has constant length for any given field; leading zeros found in this
    TEXT[!MUST]:    octet string MUST NOT be truncated.
    TEXT[!SHOULD]:    For these curves, implementations SHOULD use the approach specified
    TEXT[!SHOULD]:    in [RFC7748] to calculate the Diffie-Hellman shared secret.
    TEXT[!MUST]:    Implementations MUST check whether the computed Diffie-Hellman shared
    TEXT[!MUST]:    secret is the all-zero value and abort if so, as described in
    TEXT[!MUST]:    Section 6 of [RFC7748].
    TEXT[!SHOULD]: If implementors use an alternative
    TEXT[!SHOULD]:    implementation of these elliptic curves, they SHOULD perform the
    TEXT[!SHOULD]:    additional checks specified in Section 7 of [RFC7748].

  SECTION: [Exporters](#section-7.5)
    TEXT[!MUST]: Implementations MUST use the
    TEXT[!MUST]:    exporter_master_secret unless explicitly specified by the
    TEXT[!MUST]:    application.
    TEXT[!SHOULD]: A separate
    TEXT[!SHOULD]:    interface for the early exporter is RECOMMENDED; this avoids the
    TEXT[!SHOULD]:    exporter user accidentally using an early exporter when a regular one
    TEXT[!SHOULD]:    is desired or vice versa.
    TEXT[!MUST]: Future
    TEXT[!MUST]:    specifications MUST NOT define a use of exporters that permit both an
    TEXT[!MUST]:    empty context and no context with the same label.
    TEXT[!SHOULD]: New uses of
    TEXT[!SHOULD]:    exporters SHOULD provide a context in all exporter computations,
    TEXT[!SHOULD]:    though the value could be empty.

  SECTION: [0-RTT and Anti-Replay](#section-8)
    TEXT[!SHOULD]: Servers
    TEXT[!SHOULD]:    SHOULD provide that level of replay safety by implementing one of the
    TEXT[!SHOULD]:    methods described in this section or by equivalent means.
    TEXT[!MUST]: Therefore, in normal
    TEXT[!MUST]:    operation, clients will not know which, if any, of these mechanisms
    TEXT[!MUST]:    servers actually implement and hence MUST only send early data which
    TEXT[!MUST]:    they deem safe to be replayed.
    TEXT[!MUST]: The server MUST ensure that any
    TEXT[!MUST]:    instance of it (be it a machine, a thread, or any other entity within
    TEXT[!MUST]:    the relevant serving infrastructure) would accept 0-RTT for the same
    TEXT[!MUST]:    0-RTT handshake at most once; this limits the number of replays to
    TEXT[!MUST]:    the number of server instances in the deployment.
    TEXT[!SHOULD]: The "at most once per
    TEXT[!SHOULD]:    server instance" guarantee is a minimum requirement; servers SHOULD
    TEXT[!SHOULD]:    limit 0-RTT replays further when feasible.
    TEXT[!MUST]:    The second class of attack cannot be prevented at the TLS layer and
    TEXT[!MUST]:    MUST be dealt with by any application.

  SECTION: [Client Hello Recording](#section-8.2)
    TEXT[!MUST]: Servers MAY
    TEXT[!MUST]:    also implement data stores with false positives, such as Bloom
    TEXT[!MUST]:    filters, in which case they MUST respond to apparent replay by
    TEXT[!MUST]:    rejecting 0-RTT but MUST NOT abort the handshake.
    TEXT[!MUST]:    The server MUST derive the storage key only from validated sections
    TEXT[!MUST]:    of the ClientHello.
    TEXT[!SHOULD]:    When implementations are freshly started, they SHOULD reject 0-RTT as
    TEXT[!SHOULD]:    long as any portion of their recording window overlaps the startup
    TEXT[!SHOULD]:    time.

  SECTION: [Mandatory-to-Implement Cipher Suites](#section-9.1)
    TEXT[!MUST]:    A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256
    TEXT[!MUST]:    [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384
    TEXT[!MUST]:    [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see
    TEXT[!MUST]:    Appendix B.4).
    TEXT[!MUST]:    A TLS-compliant application MUST support digital signatures with
    TEXT[!MUST]:    rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for
    TEXT[!MUST]:    CertificateVerify and certificates), and ecdsa_secp256r1_sha256.
    TEXT[!MUST]:    TLS-compliant application MUST support key exchange with secp256r1
    TEXT[!MUST]:    (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].

  SECTION: [Mandatory-to-Implement Extensions](#section-9.2)
    TEXT[!MUST]:    In the absence of an application profile standard specifying
    TEXT[!MUST]:    otherwise, a TLS-compliant application MUST implement the following
    TEXT[!MUST]:    TLS extensions:
    TEXT[!MUST]:    All implementations MUST send and use these extensions when offering
    TEXT[!MUST]:    applicable features:
    TEXT[!MUST]:    -  "supported_versions" is REQUIRED for all ClientHello, ServerHello,
    TEXT[!MUST]:       and HelloRetryRequest messages.
    TEXT[!MUST]:    -  "signature_algorithms" is REQUIRED for certificate authentication.
    TEXT[!MUST]:    -  "supported_groups" is REQUIRED for ClientHello messages using DHE
    TEXT[!MUST]:       or ECDHE key exchange.
    TEXT[!MUST]:    -  "key_share" is REQUIRED for DHE or ECDHE key exchange.
    TEXT[!MUST]:    -  "pre_shared_key" is REQUIRED for PSK key agreement.
    TEXT[!MUST]:    -  "psk_key_exchange_modes" is REQUIRED for PSK key agreement.
    TEXT[!MUST]: Such a ClientHello
    TEXT[!MUST]:    message MUST meet the following requirements:
    TEXT[!MUST]:    -  If not containing a "pre_shared_key" extension, it MUST contain
    TEXT[!MUST]:       both a "signature_algorithms" extension and a "supported_groups"
    TEXT[!MUST]:       extension.
    TEXT[!MUST]:    -  If containing a "supported_groups" extension, it MUST also contain
    TEXT[!MUST]:       a "key_share" extension, and vice versa.
    TEXT[!MUST]:    Servers receiving a ClientHello which does not conform to these
    TEXT[!MUST]:    requirements MUST abort the handshake with a "missing_extension"
    TEXT[!MUST]:    alert.
    TEXT[!MUST]:    Additionally, all implementations MUST support the use of the
    TEXT[!MUST]:    "server_name" extension with applications capable of using it.
    TEXT[!MAY]:    Servers MAY require clients to send a valid "server_name" extension.
    TEXT[!SHOULD]:    Servers requiring this extension SHOULD respond to a ClientHello
    TEXT[!SHOULD]:    lacking a "server_name" extension by terminating the connection with
    TEXT[!SHOULD]:    a "missing_extension" alert.

  SECTION: [Protocol Invariants](#section-9.3)
    TEXT[!MUST]:    This section describes invariants that TLS endpoints and middleboxes
    TEXT[!MUST]:    MUST follow.
    TEXT[!MAY]: At the same
    TEXT[!MAY]:    time, deployments update at different rates, so a newer client or
    TEXT[!MAY]:    server MAY continue to support older parameters, which would allow it
    TEXT[!MAY]:    to interoperate with older endpoints.
    TEXT[!MUST]:    For this to work, implementations MUST correctly handle extensible
    TEXT[!MUST]:    fields:
    TEXT[!MUST]:    -  A client sending a ClientHello MUST support all parameters
    TEXT[!MUST]:       advertised in it.
    TEXT[!MUST]:    -  A server receiving a ClientHello MUST correctly ignore all
    TEXT[!MUST]:       unrecognized cipher suites, extensions, and other parameters.
    TEXT[!MUST]: In
    TEXT[!MUST]:       TLS 1.3, a client receiving a CertificateRequest or
    TEXT[!MUST]:       NewSessionTicket MUST also ignore all unrecognized extensions.
    TEXT[!MUST]:    -  A middlebox which terminates a TLS connection MUST behave as a
    TEXT[!MUST]:       compliant TLS server (to the original client), including having a
    TEXT[!MUST]:       certificate which the client is willing to accept, and also as a
    TEXT[!MUST]:       compliant TLS client (to the original server), including verifying
    TEXT[!MUST]:       the original server's certificate.
    TEXT[!MUST]: In particular, it MUST
    TEXT[!MUST]:       generate its own ClientHello containing only parameters it
    TEXT[!MUST]:       understands, and it MUST generate a fresh ServerHello random
    TEXT[!MUST]:       value, rather than forwarding the endpoint's value.
    TEXT[!MUST]:    -  A middlebox which forwards ClientHello parameters it does not
    TEXT[!MUST]:       understand MUST NOT process any messages beyond that ClientHello.
    TEXT[!MUST]:       It MUST forward all subsequent traffic unmodified.
    TEXT[!MAY]: These additions MAY
    TEXT[!MAY]:       change any message beyond the ClientHello arbitrarily.

  SECTION: [IANA Considerations](#section-11)
    TEXT[!MUST]:       IESG Approval is REQUIRED for a Y->N transition.

  SECTION: [Client](#appendix-A.1)
    TEXT[!SHOULD]: If clients need to send such alerts, they
    TEXT[!SHOULD]:    SHOULD first rekey to the handshake keys if possible.

  SECTION: [Protocol Data Structures and Constant Values](#appendix-B)
    TEXT[!MUST]:    TLS 1.3 implementations MUST NOT send them but might receive them
    TEXT[!MUST]:    from older TLS implementations.

  SECTION: [Supported Groups Extension](#appendix-B.3.1.4)
    TEXT[!MUST]:    Values within "obsolete_RESERVED" ranges are used in previous
    TEXT[!MUST]:    versions of TLS and MUST NOT be offered or negotiated by TLS 1.3
    TEXT[!MUST]:    implementations.

  SECTION: [Random Number Generation and Seeding](#appendix-C.1)
    TEXT[!SHOULD]: It is RECOMMENDED to use
    TEXT[!SHOULD]:    an existing CSPRNG implementation in preference to crafting a new
    TEXT[!SHOULD]:    one.

  SECTION: [Certificates and Authentication](#appendix-C.2)
    TEXT[!SHOULD]:    Applications SHOULD also enforce minimum and maximum key sizes.

  SECTION: [Implementation Pitfalls](#appendix-C.3)
    TEXT[!SHOULD]:    -  Do you use a strong and, most importantly, properly seeded random
    TEXT[!SHOULD]:       number generator (see Appendix C.1) when generating Diffie-Hellman
    TEXT[!SHOULD]:       private values, the ECDSA "k" parameter, and other security-
    TEXT[!SHOULD]:       critical values?  It is RECOMMENDED that implementations implement
    TEXT[!SHOULD]:       "deterministic ECDSA" as specified in [RFC6979].

  SECTION: [Client Tracking Prevention](#appendix-C.4)
    TEXT[!SHOULD]:    Clients SHOULD NOT reuse a ticket for multiple connections.
    TEXT[!SHOULD]:    Servers that issue tickets SHOULD offer at least as many tickets as
    TEXT[!SHOULD]:    the number of connections that a client might use; for example, a web
    TEXT[!SHOULD]:    browser using HTTP/1.1 [RFC7230] might open six connections to a
    TEXT[!SHOULD]:    server.
    TEXT[!SHOULD]: Servers SHOULD issue new tickets with every connection.

  SECTION: [Unauthenticated Operation](#appendix-C.5)
    TEXT[!MUST]: If no such mechanism is used, then the connection has no
    TEXT[!MUST]:    protection against active man-in-the-middle attack; applications
    TEXT[!MUST]:    MUST NOT use TLS in such a way absent explicit configuration or a
    TEXT[!MUST]:    specific application profile.

  SECTION: [Backward Compatibility](#appendix-D)
    TEXT[!MUST]: The value of
    TEXT[!MUST]:    TLSPlaintext.legacy_record_version MUST be ignored by all
    TEXT[!MUST]:    implementations.
    TEXT[!MAY]: The value of TLSCiphertext.legacy_record_version is
    TEXT[!MAY]:    included in the additional data for deprotection but MAY otherwise be
    TEXT[!MAY]:    ignored or MAY be validated to match the fixed constant value.
    TEXT[!SHOULD]: In order to maximize
    TEXT[!SHOULD]:    interoperability with older endpoints, implementations that negotiate
    TEXT[!SHOULD]:    the use of TLS 1.0-1.2 SHOULD set the record layer version number to
    TEXT[!SHOULD]:    the negotiated version for the ServerHello and all records
    TEXT[!SHOULD]:    thereafter.
    TEXT[!SHOULD]:    For maximum compatibility with previously non-standard behavior and
    TEXT[!SHOULD]:    misconfigured deployments, all implementations SHOULD support
    TEXT[!SHOULD]:    validation of certification paths based on the expectations in this
    TEXT[!SHOULD]:    document, even when handling prior TLS versions' handshakes (see
    TEXT[!SHOULD]:    Section 4.4.2.2).
    TEXT[!SHOULD]: Because TLS 1.3 always hashes in the transcript
    TEXT[!SHOULD]:    up to the server Finished, implementations which support both TLS 1.3
    TEXT[!SHOULD]:    and earlier versions SHOULD indicate the use of the Extended Master
    TEXT[!SHOULD]:    Secret extension in their APIs whenever TLS 1.3 is used.

  SECTION: [Negotiating with an Older Server](#appendix-D.1)
    TEXT[!SHOULD]:    A client using a ticket for resumption SHOULD initiate the connection
    TEXT[!SHOULD]:    using the version that was previously negotiated.
    TEXT[!SHOULD]:    Note that 0-RTT data is not compatible with older servers and
    TEXT[!SHOULD]:    SHOULD NOT be sent absent knowledge that the server supports TLS 1.3.
    TEXT[!MUST]:    If the version chosen by the server is not supported by the client
    TEXT[!MUST]:    (or is not acceptable), the client MUST abort the handshake with a
    TEXT[!MUST]:    "protocol_version" alert.
    TEXT[!SHOULD]: Multiple connection attempts may be required
    TEXT[!SHOULD]:    in order to negotiate a backward-compatible connection; however, this
    TEXT[!SHOULD]:    practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.

  SECTION: [Negotiating with an Older Client](#appendix-D.2)
    TEXT[!MUST]: If the
    TEXT[!MUST]:    "supported_versions" extension is present, the server MUST negotiate
    TEXT[!MUST]:    using that extension as described in Section 4.2.1.
    TEXT[!MUST]: If the
    TEXT[!MUST]:    "supported_versions" extension is not present, the server MUST
    TEXT[!MUST]:    negotiate the minimum of ClientHello.legacy_version and TLS 1.2.
    TEXT[!MUST]: If the "supported_versions" extension is absent and the
    TEXT[!MUST]:    server only supports versions greater than
    TEXT[!MUST]:    ClientHello.legacy_version, the server MUST abort the handshake with
    TEXT[!MUST]:    a "protocol_version" alert.
    TEXT[!MUST]: Servers will receive various
    TEXT[!MUST]:    TLS 1.x versions in this field, but its value MUST always be ignored.

  SECTION: [0-RTT Backward Compatibility](#appendix-D.3)
    TEXT[!MUST]:    A client that attempts to send 0-RTT data MUST fail a connection if
    TEXT[!MUST]:    it receives a ServerHello with TLS 1.2 or older.
    TEXT[!SHOULD]: To avoid a downgrade attack, the
    TEXT[!SHOULD]:    client SHOULD NOT disable TLS 1.3, only 0-RTT.
    TEXT[!SHOULD]:    To avoid this error condition, multi-server deployments SHOULD ensure
    TEXT[!SHOULD]:    a uniform and stable deployment of TLS 1.3 without 0-RTT prior to
    TEXT[!SHOULD]:    enabling 0-RTT.

  SECTION: [Middlebox Compatibility Mode](#appendix-D.4)
    TEXT[!MUST]:    change_cipher_spec at any time during the handshake, as they must be
    TEXT[!MUST]:    ignored by the peer, but if the client sends a non-empty session ID,
    TEXT[!MUST]:    the server MUST send the change_cipher_spec as described in this
    TEXT[!MUST]:    appendix.

  SECTION: [Security Restrictions Related to Backward Compatibility](#appendix-D.5)
    TEXT[!SHOULD]:    Implementations negotiating the use of older versions of TLS SHOULD
    TEXT[!SHOULD]:    prefer forward secret and AEAD cipher suites, when available.
    TEXT[!MUST]: Implementations MUST NOT offer or
    TEXT[!MUST]:    negotiate RC4 cipher suites for any version of TLS for any reason.
    TEXT[!MUST]:    Ciphers with a strength less than 112 bits MUST NOT be offered or
    TEXT[!MUST]:    negotiated for any version of TLS for any reason.
    TEXT[!MUST]:    The security of SSL 3.0 [RFC6101] is considered insufficient for the
    TEXT[!MUST]:    reasons enumerated in [RFC7568], and it MUST NOT be negotiated for
    TEXT[!MUST]:    any reason.
    TEXT[!MUST]:    The security of SSL 2.0 [SSL2] is considered insufficient for the
    TEXT[!MUST]:    reasons enumerated in [RFC6176], and it MUST NOT be negotiated for
    TEXT[!MUST]:    any reason.
    TEXT[!MUST]:    Implementations MUST NOT send an SSL version 2.0 compatible
    TEXT[!MUST]:    CLIENT-HELLO.
    TEXT[!MUST]: Implementations MUST NOT negotiate TLS 1.3 or later
    TEXT[!MUST]:    using an SSL version 2.0 compatible CLIENT-HELLO.
    TEXT[!SHOULD]: Implementations
    TEXT[!SHOULD]:    are NOT RECOMMENDED to accept an SSL version 2.0 compatible
    TEXT[!SHOULD]:    CLIENT-HELLO in order to negotiate older versions of TLS.
    TEXT[!MUST]:    Implementations MUST NOT send a ClientHello.legacy_version or
    TEXT[!MUST]:    ServerHello.legacy_version set to 0x0300 or less.
    TEXT[!MUST]: Any endpoint
    TEXT[!MUST]:    receiving a Hello message with ClientHello.legacy_version or
    TEXT[!MUST]:    ServerHello.legacy_version set to 0x0300 MUST abort the handshake
    TEXT[!MUST]:    with a "protocol_version" alert.
    TEXT[!MUST]:    Implementations MUST NOT send any records with a version less than
    TEXT[!MUST]:    0x0300.
    TEXT[!SHOULD]: Implementations SHOULD NOT accept any records with a version
    TEXT[!SHOULD]:    less than 0x0300 (but may inadvertently do so if the record version
    TEXT[!SHOULD]:    number is ignored completely).
    TEXT[!MUST]:    Implementations MUST NOT use the Truncated HMAC extension, defined in
    TEXT[!MUST]:    Section 7 of [RFC6066], as it is not applicable to AEAD algorithms
    TEXT[!MUST]:    and has been shown to be insecure in some scenarios.

  SECTION: [Handshake](#appendix-E.1)
    TEXT[!MUST]: Implementations
    TEXT[!MUST]:    MUST NOT combine external PSKs with certificate-based authentication
    TEXT[!MUST]:    of either the client or the server unless negotiated by some
    TEXT[!MUST]:    extension.
    TEXT[!MUST]:    Note: Exporters can produce arbitrary-length values; if exporters are
    TEXT[!MUST]:    to be used as channel bindings, the exported value MUST be large
    TEXT[!MUST]:    enough to provide collision resistance.

  SECTION: [Key Derivation and HKDF](#appendix-E.1.1)
    TEXT[!SHOULD]: This ordering should always be followed
    TEXT[!SHOULD]:    (including in future revisions of this document); in particular, one
    TEXT[!SHOULD]:    SHOULD NOT use an output of HKDF-Extract as an input to another
    TEXT[!SHOULD]:    application of HKDF-Extract without an HKDF-Expand in between.

  SECTION: [Exporter Independence](#appendix-E.1.4)
    TEXT[!SHOULD]: However, because these secrets can be used to compute any
    TEXT[!SHOULD]:    exporter value, they SHOULD be erased as soon as possible.
    TEXT[!SHOULD]: If the
    TEXT[!SHOULD]:    total set of exporter labels is known, then implementations SHOULD
    TEXT[!SHOULD]:    pre-compute the inner Derive-Secret stage of the exporter computation
    TEXT[!SHOULD]:    for all those labels, then erase the [early_]exporter_master_secret,
    TEXT[!SHOULD]:    followed by each inner value as soon as it is known that it will not
    TEXT[!SHOULD]:    be needed again.

  SECTION: [Replay Attacks on 0-RTT](#appendix-E.5)
    TEXT[!MUST]: Because clients
    TEXT[!MUST]:    do not know the exact details of server behavior, they MUST NOT send
    TEXT[!MUST]:    messages in early data which are not safe to have replayed and which
    TEXT[!MUST]:    they would not be willing to retry across multiple 1-RTT connections.
    TEXT[!MUST]:    Application protocols MUST NOT use 0-RTT data without a profile that
    TEXT[!MUST]:    defines its use.
    TEXT[!MUST]:    In addition, to avoid accidental misuse, TLS implementations MUST NOT
    TEXT[!MUST]:    enable 0-RTT (either sending or accepting) unless specifically
    TEXT[!MUST]:    requested by the application and MUST NOT automatically resend 0-RTT
    TEXT[!MUST]:    data if it is rejected by the server unless instructed by the
    TEXT[!MUST]:    application.
    TEXT[!MUST]: In order to allow applications to implement this kind of
    TEXT[!MUST]:    processing, TLS implementations MUST provide a way for the
    TEXT[!MUST]:    application to determine if the handshake has completed.

  SECTION: [Replay and Exporters](#appendix-E.5.1)
    TEXT[!SHOULD]:    In addition, the early exporter SHOULD NOT be used to generate
    TEXT[!SHOULD]:    server-to-client encryption keys because that would entail the reuse
    TEXT[!SHOULD]:    of those keys.
